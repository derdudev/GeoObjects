<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoBuilder</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="assets/gb.ico" type="image/x-icon">
    <meta property="og:url" content="https://geo-objects.netlify.app/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="GeoBuilder">
    <meta property="og:description" content="Summary of worksheet GeoObjects. Zusammenfassung vom Arbeitsblatt GeoObjects.">
    <meta property="og:image" content="https://geo-objects.netlify.app/assets/og-img.png">
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="basics"  style="margin-bottom: 10px">
                <div class="icon">INFO</div>
                <p>Zur Basics-Section geht es hier: <a href="/basics.html">Basics</a>.</p>
            </div>
            <div class="basics">
                <div class="icon">INFO</div>
                <p>Eine kurze Einf√ºhrung in UML findest du hier: <a href="/uml.html">UML</a>.</p>
            </div>
            <div class="section">
                <h2>Disclaimer</h2>
                <p>Ich besitze keinerlei Rechte an dem folgenden Gedankengut, da dies zu einem Gro√üteil auf der Arbeit vom RP Freiburg und seiner Version dieses ABs basiert.</p>
            </div>

            <div class="section">
                <h2>Stufe 1</h2>
                <p>Wir beginnen mit dem Erstellen des einfachsten geometrischen Objektes: Dem Punkt. Dabei soll ein jeder Punkt die folgenden Eigenschaften haben:</p>
                <p>Eine <code>x</code> und <code>y</code> Koordinate und eine Darstellungscolor <code>color</code>.</p>
            </div>

            <div class="section">
                <h2>Testen_GPoint.java</h2>
                <p>Eine neue Datei <code>Testen_GPoint.java</code> erstellen, dann den folgenden Quellcode einfach kopieren und einf√ºgen und abschlie√üend <code>Testen_GPoint.java</code> compilieren und ausf√ºhren.</p>
                <p>Wird in der Konsole <code>Test was successful! Good job!</code> ausgegeben, dann funktioniert deine Methode perfekt. Siehst du stattdessen eine rote Fehlermeldung, dann stimmt leider etwas noch nicht ganz mit deiner Methode.</p>
                <pre>
                    <code>
    public class Testen_GPoint {
        private GPoint p;
        public int x, y;
    
        public Testen_GPoint(){
            this.x = 2;
            this.y = 2;
            p = new GPoint(x, y);
        }
    
        public void test() throws Exception {
            if(!(p.abstandZu(4, 4) == this.distanceTo(4, 4))) throw new Exception();
            else System.out.println("Test was successful! Good job!");
        }
    
        public double distanceTo(int mx, int my){
            double dx, dy, d;
            dx = (double) mx - this.x;
            dy = (double) my - this.y;
            d = Math.sqrt(dx * dx + dy * dy);
            return d;
        }
    
        public static void main(String[] args) throws Exception {
            Testen_GPoint pointTest = new Testen_GPoint();
            pointTest.test();
        }
    }
                    </code>
                </pre>
            </div>
            <div class="section">
                <h2>Stufe 5: Neue Punkte erstellen</h2>
                <p>
                    Die Punkte sollen nun ja, nicht wie zum Ende der vorherigen Stufe beschrieben im Konstruktor der Board-Klasse, vom  Benutzer erzeugt werden. So soll bei einem Mausklick ein neues <code>GPoint</code> Objekt (mit den Koordinaten der Stelle des Klicks auf der Zeichenfl√§che) erstellt und in die Liste <code>geoObjects</code> eingef√ºgt werden.                    
                </p>
                <p>
                    Um dieses Mausklick-Event "abzufangen", k√∂nnen wir die Methode <code>Board.mousePressed(MouseEvent e)</code> benutzen. Diese wird von JAVA n√§mlich genau dann aufgerufen, wenn die prim√§re (also die linke) Maustaste gedr√ºckt wurde.
                </p>
                <p>
                    Also schreiben wir in diese <code>mousePressed()</code> Methode unseren Quellcode, der einen neuen Punkt erzeugt und der <code>geoObjects</code> Liste hinzuf√ºgt (Nach demselben Prinzip, wie wir es bereits im Konstruktor von <code>Board</code> gemacht haben).
                </p>
                <p>
                    Zur Initialisierung eines neuen <code>GPoint</code> Objektes ben√∂tigen wir eine x und y Koordinate, die diesem dann "zugewiesen" (In anderen Worten: Dem Konstruktor √ºbergeben) wird. Diese Koordinaten liefert uns der Parameter <code>MouseEvent e</code>. Ganz einfach formuliert √ºbergibt das "System" (Was auch immer hier genau das System sein mag) der <code>mousePressed()</code> Methode ein Objekt vom Typ <code>MouseEvent</code>, in welchem z.B. die Koordinaten des Mauszeigers bei Ausl√∂sung des Events gespeichert sind. 
                </p>
                <p>
                    Um nun in der Methode mit diesen Koordinaten etwas anfangen zu k√∂nnen, die in dem <code>e</code> Objekt (Das ja eigentlich der √ºbergebene Parameter der Methode ist) enthalten sind, benutzen wir folgendes Code-Snippet:
                </p>
                <pre>
                    <code class="JAVA">
    int mx = e.getX();
    int my = e.getY();
                    </code>
                </pre>
                <p>
                    So sind nach diesen beiden Zeilen die x und y Koordinate der Mausposition in <code>mx</code> und <code>my</code> gespeichert.
                </p>
                <div class="exercise">
                    <p>
                        Stelle eine Kopie deines Projekts in einem neuen Verzeichnis <code>GeomObj_D</code> her. Erg√§nze die <code>mousePressed()</code> Methode in der <code>Board</code> Klasse dann so, dass bei einem Mausklick an eine leere Stelle der Zeichnung ein neuer Punkt erzeugt wird.
                    </p>
                    <p>
                        Dieser Punkt muss dann nat√ºrlich auch noch in die <code>geoObjects</code> Liste hinzugef√ºgt werden.
                    </p>
                    <p>
                        Zus√§tzlich sollte nach dem Einf√ºgen eines neuen Punktes das <code>Board</code> neu geladen werden, damit der neue Punkt auch angezeigt wird. Dies l√§sst sich ganz einfach √ºber einen Aufruf der Methode <code>repaint()</code> ganz am Ende deines Codes in der <code>mousePressed()</code> Methode erreichen. Wunder dich nicht, dass du nirgendwo direkt eine Definition dieser <code>repaint()</code> Methode siehst, <code>Board</code> erbt diese n√§mlich von <code>JPanel</code>.
                    </p>
                </div>
                <div class="exercise">
                    <p>
                        Verschiebe den Quellcode f√ºr das Einf√ºgen von Punkten vor√ºbergehend(!) von <code>mousePressed()</code> nach <code>mouseReleased()</code> bzw <code>mouseDragged()</code>. Was √§ndert sich dabei jeweils am Verhalten des Programms?
                    </p>
                    <p>
                        Wenn du etwas mehr wissen m√∂chtest, dann kannst du √ºber den Befehl <code>System.out.println(geoObjects.size());</code> im Konsolenfenster ausgeben lassen, wie gro√ü die <code>geoObjects</code> Liste zum jeweiligen Zeitpunkt ist, d.h. wie viele Punkte schon hinzugef√ºgt wurden.
                        <br>
                        F√ºge diesen daf√ºr einfach in den Methoden <code>mousePressed()</code>, <code>mouseReleased()</code> bzw <code>mouseDragged()</code> ein.
                    </p>
                    <p>
                        Zu guter Letzt musst du nun den verschobenen Quellcode wieder zur√ºck in die <code>mousePressed()</code> Methode verschieben (und ggf. den <code>System.out...</code> Befehl wieder entfernen)
                    </p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 6: Jetzt wird's dynamisch!</h2>
                <p>
                    Nun k√∂nnen wir Punkte per Mausklick hinzuf√ºgen. Allerdings wollen wir nun diese plazierten Punkte auch verschieben k√∂nnen. 
                    Dies regeln wir wie folgt:
                </p>
                <p>
                    Wenn die Maustaste auf einen schon vorhandenen Punkt p (oder hinreichend dicht bei p) gedr√ºckt wird, dann soll dieser Punkt als <code>dragPoint</code>, also als "zu verziehender" Punkt gespeichert werden.
                    Wird nun die Maus bei weiterhin gedr√ºckter Taste bewegt, soll dieser Punkt der Mausbewegung folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Hierf√ºr m√ºssen wir nat√ºrlich erst einmal wissen, ob die Koordinaten des Mauszeigers beim Klicken in der N√§he, bzw. "ganz dicht" an einem bereits existierenden Punkt liegen. 
                </p>
                <p>
                    Dies erledigen wir in der Methode <code>mousePressed()</code> von <code>Board</code>, die ja immer dann aufgerufen wird, wenn die prim√§re Maustaste gedr√ºckt wurde. 
                </p>
                <p>
                    Dann untersuchen wir als erstes einfach alle Punkte der <code>geoObjects</code> Liste darauf, wie dicht sie bei der aktuellen Mausposition liegen. Eine daf√ºr ben√∂tigte Schleife findest du bereits in der <code>Board.paint()</code> Methode oder hier:
                </p>
                <pre>
                    <code class="JAVA">
    for (GPoint p: geoObjects) {
        // Anweisungen hier einf√ºgen
    }                   
                    </code>
                </pre>
                <p>
                    In dieser Schleife ist eine Art "Laufvariable" definiert, <code>p</code> von Typ <code>GPoint</code>. Diese Schleife "l√§uft" √ºber die Liste <code>geoObjects</code> und ihre Laufvariable <code>p</code> nimmt in jedem Durchlauf den Wert an der Stelle der Liste an, an der die Schleife momentan steht.
                    <br>
                    D.h. wenn wir annehmen, dass an der nullten Stelle von <code>geoObjects</code> das Objekt <code>GPoint point1 = new GPoint(1, 1)</code> steht, so w√ºrde die Laufvariable <code>p</code> im allerersten Schleifendurchlauf die Referenz des Objekts <code>point</code> annehmen.
                </p>
                <p>
                    Hier die ganze Erkl√§rung in Code ausgeschrieben:
                </p>
                <pre>
                    <code class="JAVA">
    ArrayList&lt;GPoint&gt; geoObjects = new ArrayList&lt;GPoint&gt;();
    GPoint point1 = new GPoint(1, 1);
    geoObjects.add(point1);
    GPoint point2 = new GPoint(2, 2);
    geoObjects.add(point2);

    for (GPoint p: geoObjects) {
        System.out.println("X: " + p.getX() + "; Y: " + p.getY());
    }                   

    // Gibt in der Konsole aus: 
    // X: 1; Y: 1
    // X: 2; Y: 2
                    </code>
                </pre>
                <p>
                    Wie gro√ü der Abstand zwischen zwei Punkten, also des Punktes <code>p</code> und der aktuellen Mausposition, ist, k√∂nnen wir √ºber einen Aufruf der bereits in Schritt 3 geschriebenen Methode <code>abstandZu()</code> der Klasse <code>GPoint</code> berechnen.
                </p>
                <p>
                    Hierf√ºr √ºbergeben wir dieser Methode einfach die Maus-Koordinaten, welche uns wie bereits in Schritt 5 erw√§hnt, √ºber den Parameter <code>e</code> des Typs <code>MouseEvent</code> √ºbergeben werden: <code>e.getX()</code> und <code>e.getY()</code> geben die jeweilige Koordinate zur√ºck.
                </p>
                <p>
                    Wir erinnern uns: Da die Methode <code>abstandZu()</code> zur Klasse <code>GPoint</code> geh√∂rt und wir sie als <code>public</code> definiert haben, k√∂nnen wir sie √ºber jedes Objekt vom Typ <code>GPoint</code> aufrufen. So dann auch √ºber die Laufvariable <code>p</code> der Schleife, da diese ja vom Typ <code>GPoint</code> ist und in jedem Durchlauf das Element in der <code>geoObjects</code> Liste an der momentanen Stelle in ihr gespeichert wird. Dar√ºber l√§sst sich ganz einfach der Abstand zwischen einem jeden Punkt, der auch ein Element in <code>geoObjects</code> ist und dem Mauscursor berechnen, indem wir √ºber das Objekt <code>p</code> (Die Laufvariable) <code>abstandZu()</code> aufrufen und dieser Methode die Koordinaten des Mauscursors, also <code>e.getX()</code> und <code>e.getY()</code> √ºbergeben.
                </p>
                <p>
                    Dieser Methodenaufruf liefert der Methodendefinition nach einen Wert von Typ <code>double</code>, den Abstand zwischen den beiden Punkten, also genau das, was wir eigentlich brauchen.
                </p>
                <p>
                    Ist der Abstand nun kleiner als 4 (Pixel), so weisen wir der Variablen <code>dragPoint</code> den Punkt p zu; andernfalls beh√§lt <code>dragPoint</code> den Wert <code>null</code> (D.h. wir m√ºssen ihn nicht erneut auf <code>null</code> setzen).
                </p>
                <p>
                    Anschlie√üend √ºberpr√ºfen wir dann, ob <code>dragPoint</code> nicht <code>null</code> ist. Wenn dies der Fall ist, soll dieser Punkt so lange der Maus folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Dies erreichen wir, indem wir in der <code>mouseDragged()</code> Methode den gezogenen Punkt, also <code>draggedPoint</code> stets an die aktuelle Mausposition setzen.
                    <br>
                    Auch in dieser Methode erhalten wir die Koordinaten des Mauszeigers √ºber den √ºbergebenen Parameter <code>e</code> des Typs <code>MouseEvent</code>:
                </p>
                <pre>
                    <code class="JAVA">
    dragPoint.setX(e.getX());
    dragPoint.setY(e.getY());
                    </code>
                </pre>
                <p></p>
                <p>
                    Nun sind zwar die Koordinaten des gezogenen Punktes aktualisiert, jedoch wird diese √Ñnderung noch nicht angezeigt.
                    <br>
                    Auch hier m√ºssen wir die Methode <code>repaint()</code> zum Neuladen, also zum Aktualisieren des Fensters aufrufen.
                </p>
                <p>
                    Was aber, wenn <code>dragPoint</code> gleich <code>null</code> ist? Dann wurde die prim√§re Maustaste an einer freien Stelle des Zeichenbreichs gedr√ºckt. In dieser Situation sollten wir also einen neuen Punkt hinzuf√ºgen - Also genau das tun, was wir bereits in Schritt 5 getan haben! 
                </p>
                <p>
                    Baue also den schon vorhandenen Quelltext zur Erzeugung eines neuen Punktes so in die neue <code>mousePressed()</code> Methode ein, dass er nur noch im Falle <code>dragPoint == null</code> ausgef√ºhrt wird.
                </p>
                <p>
                    Abschlie√üend m√ºssen wir noch den Zugvorgang beim Loslassen der Maustaste beenden. 
                    <br>
                    Hierf√ºr muss einfach in <code>mouseReleased()</code> die Variable <code>dragPoint</code> auf null zu setzen.
                </p>
                <div class="exercise">
                    <p>
                        Erstelle eine Kopie deines Projektes in einem neuen Verzeichnis <code>GeomObj_E</code> und erg√§nze die Maus-Methoden in der Klasse <code>Board</code> wie oben beschrieben.
                    </p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mousePressed()</code> {
                    </p>
                    <p style="padding-left: 20px">if-Schleife ("<i>Ist <code>dragPoint</code> nicht gleich null?</i>") {</p>
                    <p style="padding-left: 40px">for-Schleife {</p>
                    <p style="padding-left: 60px">if-Schleife (" <i> Ist der Abstand zwischen Punkt <code>p</code>(der Laufvariablen der Schleife) und dem Punkt mit den Koordinaten (<code>e.getX()</code>|<code>e.getY()</code>) kleiner als 4?" </i>) { </p>
                    <p style="padding-left: 80px">Setze <code>dragPoint</code></p>
                    <p style="padding-left: 60px">}</p>
                    <p style="padding-left: 40px">}</p>
                    <p style="padding-left: 40px">repaint</p>
                    <p style="padding-left: 20px">}</p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseDragged()</code> {
                    </p>
                    <p style="text-indent: 20px">Setze neue Koordinaten f√ºr <code>dragPoint</code></p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseReleased()</code> {
                    </p>
                    <p style="text-indent: 20px">Reset <code>dragPoint</code> (auf <code>null</code>)</p>
                    <p>}</p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 7: Andere geometrische Objekte: Strecken</h2>
                <p>
                    Nun wollen wir in unserer Applikation ja nicht nur mit Punkten arbeiten, sondern mit "komplexeren" geometrischen Objekten, wie z.B. Strecken.
                </p>
                <p>
                    Hierf√ºr ben√∂tigen wir logischerweise auch gleich eine neue Klasse <code>GLine</code>. 
                </p>
                <p>
                    Genau wie die Punkte, sollen sich auch die Strecken mit Hilfe einer <code>draw()</code> Methode im Zeichenfenster darstellen k√∂nnen.
                </p>
                <p>
                    Strecken haben stets einen Anfangs- und einen Endpunkt und (genau wie die Punkte) eine Farbe, somit ist das folgende UML-Diagramm f√ºr die Strecken naheliegend:
                </p>
                <div class="center">
                    <img src="./assets/dia1.png" alt="" srcset="">
                </div>
                <p>
                    Nun sto√üen wir allerdings schnell auf ein gro√ües Problem: Wenn wir die Klasse <code>GLine</code> fertig implementiert und eine Instanz dieser Klasse, also ein Strecken-Objekt erzeugt h√§tten, m√ºssten wir dieses ja auch in die <code>geoObjects</code> Liste eintragen.
                </p>
                <p>
                    Hier stellt sich jedoch JAVA quer - in die <code>geoObjects</code> Liste k√∂nnen ja nur Objekte vom Typ <code>GPoint</code> hinzugef√ºgt werden. 
                    <br>
                    Gleichzeitig gibt es keine M√∂glichkeit, in einer solchen <code>ArrayList</code> mehrere Objekte von verschiedenen Typen, also mehrere Instanzen verschiedener Klassen zu speichern.
                </p>
                <p>
                    Somit brauchen wir eine Art gemeinsame "Oberklasse" f√ºr <code>GPoint</code> und <code>GLine</code>. Beide Klassen beschreiben ja GeoObjekte, also bietet sich f√ºr den Namen der √ºbergeordneten Oberklasse <code>GeoObject</code> prima an.
                </p>
                <p>
                    Diese Klasse soll nun alle Eigenschaften (also Attribute) und Methoden beinhalten, die im oberen UML Diagramm sowohl in <code>GPoint</code> und <code>GLine</code> vorhanden sind.
                </p>
                <p>
                    Alle anderen Eigenschaften, in denen sich die beiden Klassen unterscheiden, bleiben damit in ihnen selbst. Damit sind <code>GPoint</code> und <code>GLine</code> jeweils Spezialisierungen von <code>GeoObject</code>.
                </p>
                <p>
                    Jedoch gleichen sich <code>GPoint</code> und <code>GLine</code> nicht zu 100%. Damit m√ºssen sie sich voneinander und vor allem von der Oberklasse unterscheiden. Die Eigenschaften, die sie spezialisieren werden also jeweils in (und nur in) <code>GPoint</code> und <code>GLine</code> definiert.
                </p>
                <p>
                    Damit sind die beiden Klassen <code>GPoint</code> und <code>GLine</code> Spezialisierungen von <code>GeoObject</code>. Sie sollen alle Eigenschaften und F√§higkeiten (Also Attribute und Methoden) von <code>GeoObject</code> besitzen und dar√ºber hinaus noch eigene Eigenschaften erg√§nzen.
                </p>
                <p>
                    Wenn eine Unterklasse die Eigenschaften einer Oberklasse haben soll, spricht man von Vererbung.
                </p>
                <p>
                    Um diese Vererbung in Code auszudr√ºcken, verwenden wir das <code>extends</code> Schl√ºsselwort in der Klassendefinition.
                </p>
                <p>Damit w√ºrde die neue Klassendefinition von <code>GPoint</code> nun wie folgt aussehen:</p>
                <pre>
                    <code class="JAVA">
    public class GPoint extends GeoObject { ... }
                    </code>
                </pre>
                <p>M√∂chte man sich unbedingt durch die H√∂lle des Java-Editors schlagen, so ist es m√∂glich einen solchen Ausdruck auch automatisch zu erzeugen, indem man im UML-Klassen-Editor auf der Registerkarte <i>Klasse</i> im Feld <i>Abgeleitet von</i> die Klasse, von der geerbt werden soll, eingetr√§gt - In unserem Fall also f√ºr <code>GPoint</code> und <code>GLine</code> jeweils <code>GeoObject</code>.</p>
                <div class="center">
                    <img src="./assets/pic1.png" style="width: 60%;">
                </div>
                <p>Andererseits (was durchaus um einiges empfehlenswerter ist), l√§sst sich nat√ºrlich der Quellcode auch direkt bearbeiten und die Klassendefinitionen von <code>GPoint</code> und <code>GLine</code> durch <code>extends GeoObject</code> wie in dem oberen Code-Snippet gezeigt, erg√§nzen.</p>
                <p>Befindest du dich noch in der UML-Ansicht, dann mache einfach einen Rechtsklick auf die entsprechende Klasse und klicke dann <i>Quelltext √∂ffnen</i>.</p>
                <p>Wenn du nun den Code richtig √ºber eine der beiden zueben genannten Methoden erg√§nzt hast und anschlie√üend zur UML-Ansicht zur√ºckkehrst, sollte diese nun in etwa so aussehen (WICHTIG: Du kannst diesen Schritt erst durchf√ºhren, wenn du die Klasse <code>GeoObject</code> bereits geschrieben hast, was aufgrund der d√§mlichen Struktur dieses ABs leider noch nicht passiert sein kann):</p>
                <div class="center">
                    <img src="./assets/pic2.png" alt="" srcset="">
                </div>
                <p>Hier f√ºhrt nun jeweils ein fetter Pfeil von jeder abgeleiteten Unterklasse, die von <code>GeoObject</code> erbt zu <code>GeoObject</code>, der das Vererbungs-Verh√§ltnis ausdr√ºckt.</p>
                <p>So kann man diese Pfeile als <i>... ist ein ...</i> lesen. F√ºr uns also:</p>
                <ul>
                    <li>Ein <code>GPoint</code> Objekt ist ein <code>GeoObject</code> ...</li>
                    <li>Ein <code>GLine</code> Objekt ist ein <code>GeoObject</code> ...</li>
                </ul>
                <p>... das hei√üt, dass sie jeweils √ºber alle Attribute und Methoden von GeoObject verf√ºgen, diese allerdings noch durch ihre eigenen speziellen Attribute und Methoden erg√§nzen.</p>
                <p>Anmerkung eine Erkl√§rung der Bedeutung der einzelnen Pfeile und deren Bezeichnung findest du in der <a href="/uml.html">Einf√ºhrung zu UML</a>.</p>
                <p>Nun werfen wir noch einen genaueren Blick auf die <code>GeoObject</code> Klasse im UML-Diagramm:</p>
                <div class="center">
                    <img src="./assets/pic3.png" style="width: 52%;">
                </div>
                <p>Hierbei f√§llt vor allem eine Sache auf: "GeoObject", also der Klassenname und die <code>draw()</code> Methode sind beide kursiv geschrieben. Was bedeutet das?</p>
                <p>Um das zu verstehen, m√ºssen wir uns nun erst einmal √ºberlegen, was die <code>draw()</code> Methode eigentlich ist.</p>
                <p>In ihr stehen jeweils die Anweisungen, die einen Punkt, bzw. eine Strecke auf das Board zeichnen.</p>
                <p>Damit implementieren <code>GPoint</code> und <code>GLine</code> diese Methode auf zwei grundlegend verschiedene Arten. Ein Punkt muss ja offensichtlich anders gezeichnet werden, als eine Strecke.</p>
                <p>Gleichzeitig soll aber auch jede Klasse, die von <code>GeoObject</code> eine Art von <code>draw()</code> Methode implementieren, da wir diese ja sp√§ter in <code>Board</code> zum eigentlichen Zeichnen des Objektes aufrufen m√ºssen.</p>
                <p>Weiter h√§ngt die genaue Implementierung dieser Methode in einer erbenden Klasse in jedem Fall von dem jeweiligen Objekt ab, das gezeichnet werden soll.</p>
                <p>Deshalb ist es auch nicht wirklich sinnvoll eine Art "Standart-Implementierung" direkt in <code>GeoObject</code> vorzunehmen und diese dann sp√§ter in den erbenden Klassen zu √ºberschreiben (Falls dir das √úberschreiben von Methoden noch kein Begriff ist, melde dich gerne bei mir üòÑ. Eventuell ist zu diesem Zeitpunkt dann auch schon eine detaillierte Erkl√§rung auf dieser Website verf√ºgbar).</p>
                <p>Die Implementierung ist sowieso in allen von <code>GeoObject</code> erbenden Klassen verschieden.</p>
                <p>Deshalb legen wir in <code>GeoObject</code> lediglich fest, dass eine von ihr erbende Klasse eine <code>draw()</code> Methode implementieren muss, die <code>public</code> sein soll, den R√ºckgabetyp <code>void</code> hat und als einzigen Parameter <code>gr</code> vom Typ <code>Graphics</code> entgegennimmt.</p>
                <p>Wie genau die <code>draw()</code> dann sonst noch aussieht, d.h. wie genau das Objekt dann gezeichnet wird, wird den jeweiligen erbenden Klassen √ºberlassen.</p>
                <p>Um diese spezielle Eigenschaft der <code>draw()</code> Methode in Code auszudr√ºcken, m√ºssen wir sie als <code>abstract</code> definieren.</p>
                <p>Eine als <code>abstract</code> definierte Methode hat in der Klasse, in der sie definiert wird (also im Fall von <code>draw()</code> die Klasse <code>GeoObject</code>) <i>keinen</i> Methodenrumpf, womit statt einem geschweiften Klammerpaar der Methodendefinition nur noch ein Semikolon folgt:</p>
                <pre>
                    <code class="JAVA">
    public abstract void draw(Graphics gr);
                    </code>
                </pre>
                <p>Sobald eine Methode einer Klasse als <code>abstract</code> definiert wurde, muss diese Klasse ebenfalls als <code>abstract</code> definiert werden, da nun keine Instanz (kein Objekt) dieser Klasse mehr erstellt werden kann. Es fehlt ja eine vollst√§ndige Definition der abstrakten Methode.</code></p>
                <p>Zusammengefasst gilt f√ºr die <code>GeoObject</code> Klasse also folgendes:</p>
                <p>Sie besitzt...</p>
                <ul>
                    <li>ein Attribut <code>color</code>, das als <code>private</code> definiert wird</li>
                    <li>einen Konstruktor <code>GeoObject()</code>, der keinen Parameter entgegennimmt. In ihm wird das Attribut <code>color</code> intialisiert. </li>
                    <li>einen Getter <code>getColor()</code> und Setter <code>setColor(Color colorNew)</code> f√ºr <code>color</code></li>
                    <li>eine abstrakte Methode <code>draw(Graphics gr)</code>, die den R√ºckgabetyp <code>void</code> besitzt, als <code>public</code> definiert wird und einen Parameter <code>gr</code> vom Typ <code>Graphics</code> entgegenimmt.</li>
                </ul>
                <p>Damit haben wir nun alle Information, die wir ben√∂tigen, um die <code>GeoObject</code> Klasse zu implementieren.</p>
                <p>Auch hier gibt es wieder zwei M√∂glichkeiten, die Eigenschaft <code>abstract</code> festzulegen.</p>
                <p>F√ºr alle, die den ungem√ºtlichen Java-Editor, bzw dessen UML-Editor verwenden wollen (und sich damit durch diesen ganzen Prozess begleitet von unz√§hligen Fehlermeldungen qu√§len werden): </p>
                <p>Im UML-Diagramm: Rechtsklick > Neue Klasse. In dem Fenster anschlie√üend <i>GeoObject</i> als Klassenname angeben und <i>Speichern</i> klicken. In dem nun neuge√∂ffneten Fenster unter der Registerkarte <i>Klasse</i> ein H√§kchen bei <i>abstrakt</i> setzen.</p>
                <p>Anschlie√üend das Attribut <code>color</code> (Wobei der Getter und Setter automatisch erstellt werden k√∂nnen) und die abstrakte Methode <code>draw(Graphics gr)</code> hinzuf√ºgen.</p>
                <p>Die Optionen f√ºr die beiden abstrakten "Neuheiten":</p>
                <div class="center">
                    <img src="./assets/pic4.png" style="width: 52%;">
                    <img src="./assets/pic5.png" style="width: 52%;">
                </div>
                <p>Alternativ kannst du nat√ºrlich auch diese ganzen Dinge im rohen Quellcode einf√ºgen.</p>
                <p>Dazu einfach die beiden Klassendefinitionen von <code>GPoint</code> und <code>GLine</code> durch ein <code>extends GeoObject</code> erg√§nzen. Und die folgende Methode einf√ºgen, bzw. ein <code>@Override</code> √ºber der alten <code>draw()</code> Methode hinzuf√ºgen:</p>
                <pre>
                    <code class="JAVA">
    @Override
    public void draw(Graphics gr){
        // Anweisungen
    }
                    </code>
                </pre>
                <p>Beachten solltest du hierbei noch, dass du nun nat√ºrlich auch alle √ºberfl√ºssigen Attribute in den erbenden Klassen entfernen solltest, da diese ja nun schon in <code>GeoObject</code> definiert sind. In unserem Fall betrifft das genau ein Attribut, n√§mlich <code>color</code>.</p>
                <div class="exercise">
                    <p>Stelle eine neue Kopie deines Projektes in einem neuen Verzeichnis <code>GeomObj_F</code> her. Bevor du <code>GeoObj.uml</code> wieder √∂ffnest, schlie√üe erst einmal alle Dateien im JavaEditor.</p>
                    <p>Erstelle gem√§√ü den Beschreibungen des Textes dieses Kapitels eine neue abstrakte Klasse <code>GeoObject</code>.</p>
                    <p>Noch einmal der Hinweis, dass du unbedingt darauf achten solltest, die Klasse <code>Color</code> √ºberall dort, wo sie verwendet wird (also auch in <code>GeoObject</code>) auch zu importieren. </p>
                    <p>Der Konstruktor von <code>GeoObject</code> hat sogar auch schon etwas zu tun: Er soll das Attribut <code>color</code> initialisieren. Daf√ºr kannst du dir prinzipiell eine beliebige Farbe aussuchen, jedoch empfiehlt sich nat√ºrlich der Einfachheit halber Schwarz.</p>
                    <p>Bearbeite dann wie bereits beschrieben die schon vorhandene Klasse <code>GPoint</code>, indem du alle nicht mehr ben√∂tigten Deklarationen entfernen und die Klasse von <code>GeoObject</code> erben lassen.</p>
                    <p>Hierbei gibt es noch eine Besonderheit zu beachten:</p>
                    <p>Der Konstruktor von jeder von <code>GeoObject</code> erbenden Klasse muss als erste Anweisung <code>super()</code> beinhalten. Dieses <code>super()</code> ruft den Konstruktor der Superklasse, also der Elternklasse <code>GeoObject</code> auf, was ja durchaus n√∂tig ist, um <code>color</code> zu initialisieren.</p>
                    <p>Teste nun, ob dein Programm immer noch so funktioniert wie vor den √Ñnderungen!</p>
                </div>
                <div class="exercise">
                    <p>Erstelle eine weitere neue Klasse <code>GLine</code>, die dem oben angegebenen UML-Diagramm entspricht.</p>
                    <p>Wenn du hier nicht ganz weiterkommst, werf einfach einen Blick auf den folgenden gr√ºn markierten Tipp-Block.</p>
                    <p>Auch hier solltest du nicht vergessen als erste Anweisung im Konstruktor <code>super()</code> aufzurufen (wie bei <code>GPoint</code>).</p>
                    <p>Implementiere abschlie√üend die <code>draw(Graphics gr)</code> Methode, indem du in ihrem Inneren die Anweisung zum Zeichnen einer Linie einf√ºgst.</p>
                    <p>Das als Parameter √ºbergebene Objekt <code>gr</code> enth√§lt eine Methode <code>drawLine()</code>. Schau dir um zu verstehen, was man ihr alles √ºbergeben muss, einmal den folgenden Screenshot aus der Dokumentation der Klasse <code>Graphics</code> an oder gehe selbst auf die <a href="https://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html#drawLine(int,%20int,%20int,%20int)">Website von Oracle</a>:</p>
                    <div class="center">
                        <img src="./assets/pic6.png" style="width: 100%;">
                    </div>
                </div>
                <div class="tipp">
                    <p>Attribute und Methoden von <code>GLine</code>:</p>
                    <ul>
                        <li><code>point1</code> und <code>point2</code> vom Typ <code>GPoint</code>, jeweils als <code>private</code> deklariert.</li>
                        <li><code>GLine(GPoint point1, GPoint point2)</code> als Konstruktor, der zwei Parameter jeweils des Typs <code>GPoint</code> entgegennimmt.</li>
                        <li>eine √ºberschriebene <code>draw()</code> Methode, deren Signatur bereits im zuvorigen Text erkl√§rt wurde.</li>
                    </ul>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 7 - Der letzte Act: Strecken verwenden</h2>
                <h3>Strecken Objekte erzeugen</h3>
                <p>Nun wollen wir ja unsere neu implementierte <code>GLine</code> Klasse auch in Aktion erleben.</p>
                <p>Damit wir nun aber √ºberhaupt erst <code>GLine</code> Objekte in <code>geoObjects</code> hinzuf√ºgen k√∂nnen, m√ºssen wir noch einige Dinge √§ndern:</p>
                <p>Zun√§chst m√ºssen wir den Typ von <code>geoObjects</code> ein wenig anpassen: Diese Liste soll ja nicht mehr nur <code>GPoint</code> Objekte beinhalten (Was durch <code>ArrayList&lt;GPoint&gt;</code> bisher noch ausgedr√ºckt wird), sondern alle Objekte, die von <code>GeoObject</code> erben.</p>
                <p>√Ñndere hierf√ºr einfach <code>ArrayList&lt;GPoint&gt;</code> um zu <code>ArrayList&lt;GeoObject&gt;</code> und ab sofort kannst du auch <code>GLine</code> Objekte in <code>geoObjects</code> speichern.</p>
                <p>Um nun unsere <code>GLine</code> Klasse zu testen, wollen wir im Konstruktor von <code>Board</code> gleich ein neues <code>GLine</code> Objekt erzeugen.</p>
                <p>Der Konstruktor von <code>GLine</code> erwartet zwei <code>GPoint</code> Objekte. Da wir im Konstruktor von <code>Board</code> ja bereits mehrere solcher Objekte erzeugt haben (Bzw. eigentlich ja nur genau eins, dieses dann aber immer wieder neu initialisiert und dann in <code>geoObjects</code> eingef√ºgt), k√∂nnen wir einfach diese verwenden.</p>
                <p>Wie aber schon angedeutet, m√ºssen wir zuvor den Quellcode zum Erzeugen der Punkte so ab√§ndern, dass wir nicht immer einen einzigen Punkt neu initialisieren, sondern vier <code>GPoint</code> Objekte <code>p1</code>, <code>p2</code>, <code>p3</code> und <code>p4</code>.</p>
                <p>Dann kannst du dem Konstruktor von <code>GLine</code> ganz einfach zwei dieser vier <code>GPoint</code> Objekte √ºbergeben und schon haben wir ein <code>GLine</code> Objekt.</p>
                <p>Jedoch muss auch dieses Objekt dann nat√ºrlich noch in die <code>geoObjects</code> Liste hinzugef√ºgt werden.</p>
                
                <h3>Strecken Objekte zeichnen</h3>
                <p>Damit die neuen <code>GLine</code> Objekte auch alle richtig gezeichnet werden, m√ºssen wir nun noch die For-Schleife in der <code>Board.paint()</code> Methode anpassen, in welcher ja jeweils die <code>draw()</code> Methode der Objekte, die in <code>geoObjects</code> gespeichert sind, aufgerufen wird.</p>
                <p>Die Laufvariable muss nun also abge√§ndert werden, da jetzt ja nicht mehr nur <code>GPoint</code> Objekte in <code>geoObjects</code> enthalten sind, sondern Objekte vom Typ <code>GeoObjects</code>.</p>
                <p>Daf√ºr m√ºssen wir also den Datentypen der Laufvariablen von <code>GPoint</code> zu <code>GeoObject</code> √§ndern. Da diese Variable dann ja immer ein <code>GeoObject</code> und nicht nur einen <code>GPoint</code> beinhaltet, benennen wir sie auch gleich von <code>p</code> (was ja f√ºr Point stand) zu <code>go</code> (f√ºr GeoObject) um.</p>
                <p>Damit wird ...</p>
                <pre>
                    <code class="JAVA">
    for(GPoint p: geoObjects){
        p.draw(gr);
    }
                    </code>
                </pre>
                <p>... zu ...</p>
                <pre>
                    <code class="JAVA">
    for(GeoObject go: geoObjects){
        go.draw(gr);
    }
                    </code>
                </pre>

                <h3>Weiter Punkte in <code>mousePressed()</code> hinzuf√ºgen</h3>
                <p>In <code>mousePressed()</code> wird nach einem Punkt in der <code>geoObjects</code> Liste gesucht, der sich dicht an der Maus befindet.</p>
                <p>Hierf√ºr l√§uft eine for-Schleife √ºber alle Eintr√§ge der Liste. Jedoch haben wir hier nun das gleiche Problem, wie bereits in der for-Schleife in der <code>Board.paint()</code> Methode. In <code>geoObjects</code> sind ja nicht mehr nur <code>GPoint</code> Objekte enthalten, sondern <code>GeoObject</code> Objekte im Allgemeinen.</p>
                <p>Damit m√ºssen wir auch hier die Laufvariable von <code>GPoint p</code> zu <code>GeoObject go</code> ab√§ndern.</p>
                <p>Nun gibt es ja aber auch die M√∂glichkeit, dass das <code>go</code> Objekt gar kein <code>GPoint</code> Objekt mehr ist und wir damit die Distanz√ºberpr√ºfung nicht mehr auf jedem Objekt in der <code>geoObjects</code> Liste aufrufen k√∂nnen, da <code>GLine</code> die Methode <code>abstandZu()</code> ja gar nicht erst implementiert.</p>
                <p>Also darf der Schleifenrumpf nur dann ausgef√ºhrt werden, wenn das aktuelle Listenobjekt, was ja in der Laufvariable <code>go</code> gespeichert ist, wirklich vom Typ <code>GPoint</code> ist.</p>
            </div>
            <div class="section">
                <h2>Polymorphie</h2>
                <p>Zuletzt m√∂chte ich in diesem Abschnitt noch auf eine weitere Besonderheit, die sich aus der <code>Board.paint()</code> Methode erkennen l√§sst, eingehen.</p>
                <p>Wenn wir hierbei kurz einen Blick auf diese werfen, f√§llt uns etwas auf (Die ersten 4 Zeilen der Methode sind f√ºr uns erst einmal irrelevant):</p>
                <pre>
                    <code class="JAVA">
    public void paint(Graphics g) {
        super.paint(g);
        BasicStroke stroke2 = new BasicStroke(2.0f, BasicStroke.CAP_BUTT,
                BasicStroke.JOIN_MITER);
        ((Graphics2D) g).setStroke(stroke2);

        for (GeoObject go : geoObjects ) {
            go.draw(g);
        }
    }
                    </code>
                </pre>
                <p>Mithilfe der for-Schleife iterieren wir √ºber die <code>ArrayList</code> <code>geoObjects</code>. Wie bereits erkl√§rt, nimmt die Laufvariable <code>go</code>, die vom Typ <code>GeoObject</code> sein muss, da in <code>geoObjects</code> ja sowohl <code>GPoint</code> als auch <code>GLine</code> oder andere GeoObjekte gespeichert werden k√∂nnen, in jedem Schleifendurchlauf den Wert des momentanen Elements in dieser <code>ArrayList</code> an.</p>
                <p>Das Objekt <code>go</code> kann somit sowohl ein <code>GPoint</code>, als auch ein <code>GLine</code> oder anderes von <code>GeoObject</code> erbendes Objekt sein.</p>
                <p>Das hei√üt, dass die <code>draw()</code> Methode jeweils aus einem anderen "Kontext" aufgerufen werden kann. In unserem Fall sind das bisher die Methoden: <code>GPoint.draw()</code> und <code>GLine.draw()</code>.</p>
                <p>Da sich die Implementierung der beiden genannten <code>draw()</code> Methoden unterscheidet, da beide Klassen ja ihre eigene Version von <code>draw()</code> implementieren, spricht man hier von <b>Polymorphie</b>.</p>
                <p>Polymorphie meint einfach nur, dass sich hinter einem Ausdruck (hier: <code>go.draw()</code>) verschiedene Methoden-Implementierungen verbergen k√∂nnen, weil jedes von <code>GeoObject</code> erbende Objekt die Methode <code>draw()</code> √ºberschreiben und damit seine eigene Version implementieren muss.</p>
            </div>
        </div>
    </div>
</body>
</html>