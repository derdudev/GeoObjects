<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoBuilder</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="assets/gb.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="section">
                <h2>Disclaimer</h2>
                <p>Ich besitze keinerlei Rechte an dem folgenden Gedankengut, da dies zu einem Gro√üteil auf der Arbeit vom RP Freiburg und seiner Version dieses ABs basiert.</p>
            </div>
            <div class="section">
                <h2>Basics</h2>
                <p>In diesem Absatz gehe ich so verst√§ndlich wie m√∂glich auf einige Basis-Konzepte von Java ein und versuche sie anhand von einfachen Beispiel zu erl√§utern.</p>
            </div>
            <div class="section">
                <h2>Basics - Das Konzept von objektorientierter Programmierung</h2>
                <p>In objektorientierter Programmierung (Absofort mit OOP abgek√ºrzt) dreht sich alles um <b>Objekte</b>.</p>
                <p>Die erste Frage, die sich einem dann hierbei stellt, ist wom√∂glich: <i>Sch√∂n, was aber ist jetzt ein Objekt? Also was kann es und wie macht man eins?</i></p>
                <p>Diese Frage l√§sst sich am besten mit einem praktischen Beispiel erl√§utern. Gehen wir nun einmal davon aus, dass wir irgendwie in der Welt des Programmierens in Java ein Auto darstellen wollen.</p>
                <p>Nun, genau f√ºr solche F√§lle sind Objekte gedacht. Wir betrachten ein Auto nun also nicht einfach nur als Ding, sondern als Objekt. Ein Auto hat bestimmte Eigenschaften und kann bestimmte Dinge tun. Genau so soll also auch ein Objekt funktionieren.</p>
                <p>Die Eigenschaften eines Objektes nennt man hierbei <b>Attribute</b>, w√§hrend die F√§higkeiten eines Objektes, also die Dinge, die es "tun kann", <b>Methoden</b> genannt werden.</p>
                <p>Wie erstellen wir nun aber ein Auto?</p>
                <p>Genau hier kommen dann <b>Klassen</b> ins Spiel. Eine Klasse kann als Blueprint, als Bauplan f√ºr ein Objekt angesehen werden, der genau festlegt, wie ein Objekt einmal auszusehen hat, d.h. was es alles f√ºr Eigenschaften und F√§higkeiten haben soll.</p>
                <p>In einer Klasse definieren wir Attribute und Methoden, √ºber die dann ein Objekt dieser Klasse (Auch genannt <b>Instanz</b>) verf√ºgen soll.</p>
                <p>Um das alles einmal praktisch zu veranschaulichen, versuchen wir nun einfach einmal ein sehr einfaches Auto Objekt in Java zu erstellen.</p>
                <p>Hierf√ºr m√ºssen wir uns zu allererst einmal √ºberlegen, welche Eigenschaften und F√§higkeiten ein Auto √ºberhaupt besitzen soll.</p>
                <p>Nun, f√ºr unser vereinfachtes Beispiel hat ein Auto auf jeden Fall eine Farbe, einen Modelname und kann hupen und fahren.</p>
                <p>Damit h√§tten wir zwei Attribute und zwei F√§higkeiten, die ein Auto Objekt also besitzen muss.</p>
                <p>Um nun ein Auto Objekt erstellen zu k√∂nnen, m√ºssen wir erstmal den Bauplan f√ºr das Auto, also die Klasse f√ºr das Auto entwerfen.</p>
                <p>Diese nennen wir passend <code>Auto</code>.</p>
                <p>Sie soll zwei Attribute, eine Farbe <code>color</code> und einen Modelname <code>modelName</code> und zwei Methoden <code>hupen()</code> und <code>fahren()</code> haben.</p>
            </div>
            <div class="section">
                <h2>Basics - Encapsulation</h2>
                <p>Wir bleiben weiter bei den Beispiel des Autos.</p>
                <p>Um uns nun weiter der Erstellung der <code>Auto</code>-Klasse anzun√§hern, wenden wir auch gleich ein sehr wichtiges Konzept der OOP an: Encapsulation (DE: Verkapselung).</p>
                <p>In dieser geht es darum die Eigenschaften verschiedener Klassen, also sp√§ter Objekten, voneinander abzugrenzen. Dies k√∂nnen wir durch die Verwendung von Sichtbarkeits-Modifizierern erreichen. Durch diese legen wir n√§mlich fest, auf welche Eigenschaften welches Objekt zugreifen kann.</p>
                <p>In Java stehen uns die folgenden zur Verf√ºgung: <code>public</code>, <code>private</code> und <code>protected</code>.</p>
                <p>Der Sichtbarkeits-Modifizierer <code>public</code> bedeutet, dass auf dieses Attribut oder diese Methode direkt von au√üen zugegriffen werden kann. Das hei√üt, dass auch von au√üerhalb des Objektes direkt √Ñnderungen an einem Attribut (das also als <code>public</code> definiert wurde) eines anderen Objektes vorgenommen werden k√∂nnen.</p>
                <p>Das komplette Gegenteil von <code>public</code> ist, wie es der Name schon vermuten l√§sst, <code>private</code>. Auf ein Attribut, was als <code>private</code> definiert wurde, kann niemals direkt von au√üerhalb des Objektes darauf zugegriffen werden. Um jedoch immernoch √Ñnderungen an diesem Attribut vornehmen zu k√∂nnen, werden sogenannte <b>Getter</b> und <b>Setter</b> Methoden verwendet.</p>
                <p>Das Praktische an diesen Bezeichnungen ist, dass sie bereits im Vorhinein quasi alles √ºber ihre Funktion verraten.</p>
                <p>√úber einen Getter k√∂nnen wir den Wert eines Attributes lesen, ohne dabei direkt von au√üen auf dieses Attribut zuzugreifen. Wie der Name vermuten l√§sst, "getten" wir etwas durch ihn - Er gibt etwas zur√ºck, n√§mlich den Wert des privaten Attributes.</p>
                <p>Ein Setter erlaubt es uns, ihm einen Wert zu √ºbergeben und dann den Wert des entsprechenden Attributes auf diesen √ºbergebenen Wert zu setzen. </p>
                <p>√úber diese beiden Umwege k√∂nnen wir also, obwohl wir ein Attribut als <code>private</code> definiert haben, dessen Wert noch √§ndern. Der wichtige Unterschied hierbei ist, dass wir es in diesem Fall allerdings nicht direkt tun.</p>
                <p>Das gleiche, was ich nun bereits f√ºr Attribute erl√§utert habe, gilt auch f√ºr Methoden (nahezu). Bei Methoden weisen wir nun jedoch keinen Wert mehr zu, sondern wollen etwas ausf√ºhren, etwas tun.</p>
                <p>Damit regeln die Sichtbarkeits-Modifizierer von Methoden "nur noch", ob auf die jeweiligen Methoden von au√üerhalb oder nur von innerhalb eines Objektes aus zugegriffen werden kann.</p>
                <p>Ist eine Methode als <code>public</code> definiert, kann auch von au√üerhalb des Objektes auf die Methode zugegriffen werden. Bei <code>private</code> ist das genaue Gegenteil der Fall.</p>
                <p>Was genau das alles nun im Klartext bedeutet, wird hoffentlich bei der weiteren Ausf√ºhrung der Erstellung unserer <code>Auto</code> Klasse klar.</p>
                <p>Abschlie√üend sei zu diesem Absatz noch gesagt, dass der Sichtbarkeits-Modifizierer <code>protected</code> eine besondere Funktion hat, auf die ich erst im weiteren Verlauf dieses ABs eingehen werde. Bisher nur soviel: Seine Funktion hat etwas mit einem weiteren extrem wichtigen Konzept der OOP zu tun, der Vererbung. Hierzu jedoch sp√§ter mehr.</p>
            </div>
            <div class="section">
                <h2>Basics - Methoden</h2>
                <p>Zuvor bin ich bereits auf Methoden im Allgemeinen ein wenig √ºber die Beschreibung der Getter und Setter eingegangen.</p>
                <p>Hierzu sind bestimmt einige Fragen entstanden, die ich nun versuchen werde in diesem Abschnitt zu erl√§utern.</p>
                <p>Was genau bedeutet es denn, wenn einer Methode ein oder mehrere Werte √ºbergeben werden?</p>
                <p>Um sich das auf eine sehr simple Art zu veranschaulichen, betrachten wir im folgenden eine Methode als eine Art mathematische Funktion.</p>
                <p>In diesem Beispiel sollte dann auch gleich das Konzept einer Methodenr√ºckgabe klarer werden.</p>
                <p>Wir versuchen nun einfach mal (unabh√§ngig zu dem Auto Beispiel aus den zuvorigen Abschnitten!) eine Methode f√ºr das Summieren zweier Ganzzahlen zu schreiben.</p>
                <p>Daf√ºr m√ºssen wir, wie bei einer mathematischen Funktion, erst einmal einen oder mehrere Werte in sie "hineinstecken", um einen weiteren "heraus", also zur√ºckzubekommen.</p>
                <p>In Java m√ºssen wir beachten, dass Java es vorschreibt (abgesehen von lambda-Funktionen - doch diese lassen wir in diesem AB au√üer Acht, bei mehr Interesse gerne direkt bei mir nachfragen), dass jede Funktion in einer Klasse steht und damit im Endeffekt nur √ºber ein Objekt dieser Klasse oder in einem Objekt dieser Klasse aufgerufen werden kann.</p>
                <p>Ferner startet jedes Java-Programm immer in der <code>main</code> Methode, die sich in jedem Java-Programm in der folgenden Form auffinden l√§sst: </p>
                <pre>
                    <code class="JAVA">
    public static void main(String[] args) {
        // Anweisungen
    }
                    </code>
                </pre>
                <p>Hier finden wir auch gleich einen nun bereits bekannten Sichtbarkeits-Modifizierer, <code>public</code>, der von einem weiteren bisher unbekanntnen Schl√ºsselwort <code>static</code> und schlie√ülich <code>void</code> gefolgt wird, bis wir schlie√ülich beim Methodennamen <code>main</code> angekommen sind.</p>
                <p>In den Klammern folgt dann ein sogenannter Parameter, <code>args</code> vom Typ <code>String[]</code> (Was genau das nun bedeutet, ist zum jetzigen Stand erst einmal unwichtig). Auf dieses Konzept gehe ich nun im Bezug auf unsere Summen-Methode ein.</p>
                <p>Parameter erlauben es uns, einer Methode Werte von au√üen zu √ºbergeben, mit denen wir dann etwas in der Methode anstellen k√∂nnen.</p>
                <p>So m√ºssen wir, um das Ergebnis einer Addition von zwei Ganzzahlen zu erhalten, unserer Methode zwei Parameter √ºbergeben: Den ersten und den zweiten Summanden.</p>
                <p>Da wir nur mit ganzen Zahlen rechnen, sollen beide Parameter von Typ <code>int</code> sein und die Namen <code>sum1</code> und <code>sum2</code> haben.</p>
                <p>Diese zwei √ºbergebenen Werte rechnen wir in unserer Methode zusammen und geben das Ergebnis wieder zur√ºck.</p>
                <p>So k√∂nnte eine relativ lange Version f√ºr unsere Additions-Methode wie folgt aussehen:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        int result = sum1 + sum2;
        return result;
    }
                    </code>
                </pre>
                <p>Wenn wir nun diese Methode einmal mit der <code>main</code> Methode vergleichen, f√§llt direkt etwas auf: Wo ist das <code>void</code> der <code>main</code> Methode hin?</p>
                <p>Nun, √ºber dieses <code>void</code> sagen wir dem Java-Compiler, dass eine Methode <i>keinen</i> Wert zur√ºckgibt, also genau das, was wir nicht wollen.</p>
                <p>Gerade unsere Additions-Methode soll ja aber das Ergebnis dieser Addition zur√ºckgeben.</p>
                <p>Also m√ºssen wir den R√ºckgabetypen dieser Methode √§ndern. Geben wir etwas in einer Methode zur√ºck, m√ºssen wir festlegen, von welchem Typ der zur√ºckgegebene Wert sein wird.</p>
                <p>In unserem Fall wissen wir ja, dass wir nur mit Ganzzahlen, also keinen Kommazahlen rechnen und k√∂nnen demnach den Datentyp <code>int</code> als R√ºckgabetyp festlegen.</p>
                <p>Und wie geben wir nun einen Wert zur√ºck?</p>
                <p>Dies erledigen wir √ºber die <code>return</code> Anweisung. Der Wert, der ihr folgt, wird zur√ºckgegeben.</p>
                <p>In unserer Additions-Methode geben wir den Wert von der Variablen <code>result</code> des Typs <code>int</code> zur√ºck. In dieser Variablen ist das eigentliche Ergebnis der Addition der beiden Summanden gespeichert.</p>
                <p>Um die Methode ein wenig k√ºrzer zu halten, w√§re folgendes auch vollkommen legitim:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        return sum1 + sum2;
    }
                    </code>
                </pre>
                <p>Dann testen wir doch einfach mal unsere Methode!</p>
                <p>Da in Java alles in Klassen stehen muss, m√ºssen wir also erst eine neue Datei erstellen und in dieser eine Klasse definieren, die allerdings keinerlei Eigenschaften besitzen muss. In ihr muss sich nur die <code>main</code> Methode befinden. Denn in dieser startet ja die Ausf√ºhrung unseres Java-Programms.</p>
                <p>Weiter ist es in Java notwendig die eigentliche Datei so zu nennen, wie die in ihr definierte Klasse hei√üt.</p>
                <p>Wir nennen unsere "Anfangsklasse" einfach <code>Main</code> und f√ºgen in diese das Code-Snippet der <code>main</code> Methode von weiter oben ein.</p>
                <p>Um im Java-Editor eine leere Java-Datei zu erstellen, klicke auf <code>Datei > Neu > Java</code> oder dr√ºcke <code>Strg + N</code></p>
                <p>Um diese Datei dann zu speichern und ihr einen Namen zu geben, klicke auf <code>Datei > Speichern</code> oder dr√ºcke <code>Strg + S</code>.</p>
                <p>In dem neu ge√∂ffneten Fenster kannst du nun den Speicherort und den Dateinamen festlegen.</p>
                <p>Abschlie√üend einfach auf <code>Speichern</code> klicken.</p>
                <p>Damit sollte in der Datei <code>Main.java</code> nun folgendes stehen:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>Um nun unsere eigene Methode auszuprobieren, m√ºssen wir diese einfach in die <code>Main</code> Klasse einf√ºgen und (!) das Schl√ºsselwort <code>static</code> hinzuf√ºgen.</p>
                <p>Warum genau dies nun n√∂tig ist w√ºrde nun etwas den Rahmen sprengen, deshalb sei lediglich gesagt, dass es notwendig ist und sonst einen Fehler geben w√ºrde, weil wir unsere Methode sp√§ter aus der <code>main</code> Methode und damit aus einem statischen Kontext ausrufen werden, wodurch die aufgerufene Methode automatisch auch als <code>static</code> definiert sein muss.</p>
                <p>Damit sieht die fertige <code>Main</code> Klasse nun so aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }
                    </code>
                </pre>
                <p>Jedoch k√∂nnen wir bisher immer noch nicht sehen, was unsere eigene <code>sum()</code> Methode denn zur√ºckgibt.</p>
                <p>Daf√ºr m√ºssen wir sie ja erstmal irgendwo aufrufen und ihr dabei zwei Werte von Typ <code>int</code> √ºbergeben, denn so haben wir es ja in unserer Methoden-Definition festgelegt.</p>
                <p>Hierf√ºr deklarieren wir in der <code>main()</code> Methode eine Variable <code>addition</code> vom Typ <code>int</code>.</p>
                <p>Anschlie√üend weisen wir ihr einen Wert zu. Jedoch nicht wie bisher direkt eine Zahl, sondern den Wert, den <code>sum()</code> zur√ºckgibt, wenn wir ihr zwei Ganzzahlen √ºbergeben.</p>
                <p>√úber den Befehl <code>System.out.println()</code> (Was im √ºbrigen auch einfach nur ein Methoden-Aufruf ist), k√∂nnen wir uns Werte auf der Konsole ausgeben lassen. N√§mlich genau den Wert, den wir ihr als Parameter (oder auch Argument genannt) √ºbergeben.</p>
                <p>Damit sieht unser fertiges Additions-Programm wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            int addition;
            addition = sum(2, 3);
            System.out.println(addition);
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }

    // Nach Complilieren und Ausf√ºhren wird auf der Konsole ausgegeben:
    // 5
                    </code>
                </pre>
                <p>Versuche doch einfach mal eine Methode <code>mul()</code> f√ºr die Multiplikation zweier Ganzzahlen zu schreiben. Oder wie sieht es denn aus, wenn wir drei statt nur zwei Zahlen addieren wollen?</p>
                <p>Probiere einfach ein bisschen herum, das f√∂rdert nur dein Verst√§ndnis!</p>
            </div>

            <div class="section">
                <h2>Basics - Zur√ºck zur Konstruktion des Autos</h2>
                <p>Nun mit unserem neuen Wissen wollen wir das Beispiel von einem Auto Objekt einmal zuende f√ºhren.</p>
                <p>Um einmal zu rekapitulieren:</p>
                <ul>
                    <li>Unser Auto Objekt soll folgende Attribute und Methoden besitzen: <code>color</code>, <code>model</code>, <code>fahren()</code> und <code>hupen()</code></li>
                    <li>Nach dem Konzept der Encapsulation m√ºssen wir uns nun √ºberlegen, welche Attribute und Methoden nach au√üen sichtbar sein sollen und welche nicht. In anderen Worten: Auf welche Eigenschaften von au√üen zugegriffen werden kann.</li>
                    <li>Zus√§tzlich m√ºssen wir auch erst einmal √ºberlegen, was genau wir in den Attributen speichern wollen. Daraus legen wir dann die entsprechenden Datentypen fest.</li>
                </ul>
                <p>Was muss denn nun alles von au√üen direkt aufrufbar sein?</p>
                <p>Nun, <code>color</code>, <code>model</code> m√ºssen ja eigentlich nicht wirklich direkt von au√üen abrufbar sein. Eventuell wollen wir sie im Laufe des Programmes einmal auslesen oder sogar √§ndern, ein Auto kann ja auch neu lackiert werden und das k√∂nnen wir dann ja √ºber den indirekten Zugriff √ºber die Getter und Setter regeln.</p>
                <p>Das hei√üt, dass wir <code>color</code> und <code>model</code> auf jeden Fall als <code>private</code> definieren werden.</p>
                <p>Bleibt noch die Frage des Datentyps.</p>
                <p>Der einfachere Fall zuerst: In <code>model</code> wollen wir ja einen Modelnamen speichern. Und aus was besteht ein Name? Genau, aus vielen aneinandergeh√§ngten Zeichen. Damit f√§llt unsere Wahl des Datentyps von <code>model</code> eindeutig auf <code>String</code>, da sich in einem <code>String</code> Zeichenketten speichern lassen.</p>
                <p>In <code>color</code> soll ja eine Farbe gespeichert werden. Dies k√∂nnten wir zwar ganz einfach durch eine Zeichenkette, also einen <code>String</code> realisieren, indem wir z.B. einfach den hex-code einer Farbe als <code>String</code> in <code>color</code> speichern, jedoch ist das relativ unpraktisch.</p>
                <p>Da kommt es uns nur gelegen, dass Java bereits eine eigene Klasse <code>Color</code> definiert hat, die es uns erlaubt simpel <code>Color</code> Objekte zu erstellen, in denen wir dann die Werte f√ºr R (Rot), G (Gr√ºn) und B (Blau) speichern k√∂nnen und uns zus√§tzlich noch einige andere sehr praktische Methoden zur Verf√ºgung stehen.</p>
                <p>Wichtig hierbei ist noch, dass wir, um diese Klasse in unserem Quellcode verwenden zu k√∂nnen, sie erst √ºber den folgenden Befehl, den wir sp√§ter ganz oben in die erste Zeile unseres Programms schreiben, importieren m√ºssen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;
                    </code>
                </pre>
                <p>Um ein Objekt <code>color</code> des Typs <code>Color</code> zu erstellen, verwenden wir folgendes Code-Snippet:</p>
                <pre>
                    <code class="JAVA">
    Color color = new Color(255, 0, 0);
                    </code>
                </pre>
                <p>Bevor ich nun genauer auf die Erkl√§rung dieses Snippets eingehe, erst noch ein paar Worte zu der Formulierung "<i>Ein Objekt ... des Typs ...</i>":</p>
                <p>Mit dieser Formulierung l√§sst sich ausdr√ºcken mithilfe welcher Klasse ein Objekt erstellt wird.</p>
                <p>So bedeutet in unserem Fall "<i>ein Objekt <code>color</code> des Typs <code>Color</code></i>", dass das Objekt <code>color</code> durch die Klasse <code>Color</code> festgelegt und sie damit also der Bauplan f√ºr das Objekt ist.</p>
                <p>In ihr steht also genau definiert, welche Eigenschaften und F√§higkeiten, also Attribute und Methoden ein Farb-Objekt haben sollte.</p>
                <p>Jetzt aber mal zur richtigen Erkl√§rung des Snippets:</p>
                <p>Bisher sind wir nur darauf eingegangen, was eine Klasse eigentlich ist und wof√ºr wir sie ben√∂tigen. Die Frage, wie wir denn nun ein Objekt nach dem Bauplan, den die Klasse vorgibt, erstellen ist allerdings immer noch offen.</p>
                <p>Das magische Wort lautet hier <b>Konstruktor</b>.</p>
                <p>Was ist nun aber ein Konstruktor?</p>
                <p>Jede Klasse muss √ºber eine Methode verf√ºgen, die bei der Erzeugung eines Objekts der Klasse aufgerufen wird. In dieser Methode k√∂nnen dann Werte initialisiert und erste Anweisungen durchgef√ºhrt werden. Diese Methode hei√üt Konstruktor.</p>
                <p>Er wird bei der Erstellung, also bei der Konstruktion eines Objekts aufgerufen.</p>
                <p>F√ºr ihn gibt es ein paar Sonderregeln, die immer gelten:</p>
                <p>Die wichtigste davon ist dabei mit Sicherheit die folgende: Der Konstruktor muss immer in jeder Klasse ohne Ausnahme wie die Klasse benannt sein.</p>
                <p>Gleichzeitig muss er immer als <code>public</code> definiert werden, da er ja von au√üerhalb eines Objektes aufgerufen wird.</p>
                <p>Eine weitere Besonderheit ist, dass ein Konstruktor niemals einen R√ºckgabetyp hat, in seiner Definition also nie ein <code>void</code> oder ein Datentyp stehen darf.</p>
                <p>Im Gro√üen und Ganzen ist der Konstruktor aber eben auch nur eine Methode.</p>
                <p>Das hei√üt f√ºr ihn gelten mit den paar zuvor genannten Einschr√§nkungen, exakt dieselben Regel wir f√ºr jede andere beliebige Methode.</p>
                <p>Also k√∂nnen wir auch einem Konstruktor bestimmte Parameter √ºbergeben, mit denen wir dann etwas in ihm anstellen k√∂nnen.</p>
                <p>So wollen wir ja schon bei der Erstellung eines Auto-Objektes unsere eigenen Farbe und den Modelnamen individuell festlegen lassen.</p>
                <p>Mit diesem ganzen neuen Wissen ist es uns nun sogar schon m√∂glich eine erste Version (bisher ohne weitere Methoden, als den Konstruktor) der Klasse <code>Auto</code> zu entwerfen.</p>
                <p>Um es einmal davor noch kurz und knapp zusammenzufassen:</p>
                <ul>
                    <li>Die Klasse soll die zwei Attribute <code>color</code> und <code>model</code> besitzen, die beide als <code>private</code> definiert werden. Dabei hat <code>color</code> den Datentyp <code>Color</code> und <code>model</code> den bereits bekannten Datentyp <code>String</code>.</li>
                    <li>Au√üerdem ben√∂tigt sie einen Konstruktor, der den gleichen Namen wie sie selbst hat - Also <code>Auto()</code> - und als <code>public</code> definiert ist. <br> Au√üerdem soll er die beiden Parameter <code>color</code> vom Typ <code>Color</code> und <code>model</code> vom Typ <code>String</code> entgegennehmen.</li>
                </ul>
                <p>Damit sieht unser erster Entwurf der <code>Auto</code> Klasse wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return this.color;
        }
        public void setColor(Color newColor){
            this.color = newColor;
        }

        public String getModel(){
            return this.model;
        }
        public void setModel(String newModel){
            this.model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei sei noch zu beachten, dass die Attribute bei ihrer Deklaration nicht direkt mit einem Wert initialisiert werden, sondern dies in dem Konstruktor geschehen soll.</p>
                <p>Eine Au√ünahme hierf√ºr stellen konstante Attribute dar, da diese immer direkt in ihrer Deklaration initialisiert werden m√ºssen. Anschlie√üend kann ihr Wert jedoch auch an keinem Punkt in unserem Programm abge√§ndert werden.</p>
                <p>W√ºrden wir zum Beispiel davon ausgehen, dass die R√§deranzahl eines Autos immer nur gleich 4 sein sollte, so k√∂nnten wir das folgende Attribut einf√ºgen (Das kannst du auch gerne tun üòÑ. F√ºr den weiteren Verlauf dieses Turtorials ist dies allerdings irrelevalt):</p>
                <pre>
                    <code class="JAVA">
    private final int tires = 4;
                    </code>
                </pre>
                <p>Zuletzt noch ein paar Worte zu den Gettern und Settern der beiden privaten Attribute:</p>
                <p>In diesen Methoden ist dir wahrscheinlich schon das Schl√ºsselwort <code>this</code> aufgefallen. In diesen F√§llen ist es zwar nicht notwendig, sp√§ter werden wir allerdings noch sehen, warum wir es verwenden sollten.</p>
                <p>Unter <code>this</code> kannst du eine Art Referenz auf das eigene Objekt verstehen. Ein Ausdruck wie <code>this.color</code> bezieht sich also immer direkt auf das Objekt, bzw. genau das Attribut dieses Objektes, aus dem es aufgerufen wird.</p>
                <p>Die folgende Version des Quellcodes w√§re damit auch vollkommen korrekt, wenn auch nicht gleich leicht verst√§ndlich:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Der Bauplan formt sich immer mehr und mehr</h2>
                <p>Unser erster Entwurf steht jetzt. Wir k√∂nnen die Dateien zwar schon komplilieren, jedoch fehlt noch eine kleine Sache.</p>
                <p>Setzen wir denn schon irgendwo die Werte der beiden Attribute?</p>
                <p>Um herauszufinden, was hier fehlt, erstelle, wenn du es bisher nicht sowieso von alleine weise vorausschauend gemacht hast, einen neuen Ordner und erstelle in diesem eine neue Datei f√ºr die Main-Klasse und eine weitere f√ºr die Auto-Klasse</p>
                <p>Ausgehend davon, dass der Ordner <i>AutoProject</i> hei√üt, sieht die Ordnerstruktur also wie folgt aus:</p>
                <pre>
                    <code class="DIR">
    AutoProjekt
        > Main.java
        > Auto.java
                    </code>
                </pre>
                <p>Den Basis-Code f√ºr eine die "Start"-Klasse, in der sich die <code>main()</code> Methode befindet, k√∂nnen wir hierbei einfach aus den Beispielen von zuvor kopieren und in <code>Main.java</code> einf√ºgen.</p>
                <p>Damit steht in <code>Main.java</code>:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>In die <code>Auto</code> Klasse f√ºgst du einfach den Entwurf aus dem letzten Abschnitt ein:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;

    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei darfst du jedoch nicht den Import der <code>Color</code> Klasse vergessen, sonst meckert der Compiler bereits beim Kompilieren.</p>
            </div>

            <div class="section">
                <h2>Basics - Initialisierung im Konstruktor</h2>
                <p>Wie ich im letzen Abschnitt bereits ein wenig vorweg genommen habe, weisen wir unseren beiden Attributen bisher noch nirgendwo Werte zu.</p>
                <p>Das hei√üt sie zeigen bisher noch auf gar keine Referenz oder einen Wert, sondern lediglich <code>null</code>.</p>
                <p>Aus dem Abschnitt Konstruktoren im Allgemeinen ist dir eventuell noch im Kopf geblieben, f√ºr was sie denn normalerweise verwendet werden. N√§mlich f√ºr die Initialisierung von Attributen.</p>
                <p>In unserem Fall wollen wir daf√ºr ja dem Konstruktor zwei Werte √ºbergeben, die er dann den beiden Attributen zuweist.</p>
                <p>Also schreiben wir doch einfach mal den Code hierf√ºr. Das sollte leicht getan sein, sollte der Konstruktor also so aussehen:</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        color = color;
        model = model;
    }
                    </code>
                </pre>
                <p>Nun ja... </p>
                <p>Das ist doch schon etwas sehr verwirrend.</p>
                <p>Der Java-Compiler versteht zwar genau, was wir eigentlich meinen, wir selbst sind allerdings etwas verwirrt.</p>
                <p>Um diese Verwirrung zu beseitigen, verwenden wir f√ºr solche F√§lle einfach das <code>this</code> Schl√ºsselwort, um eindeutig zu zeigen, welche Variable woherkommt.</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        this.color = color;
        this.model = model;
    }
                    </code>
                </pre>
                <p>So ist nun klar ersichtlich, dass der Teil des Ausdrucks links neben dem Gleichheitszeichen sich eindeutig auf das Attribut der Klasse bezieht und der rechte Teil die beiden Parameter meint.</p>
            </div>

            <div class="section">
                <h2>Basics - Unser Auto soll fahren!</h2>
                <p>Da unser Auto bisher noch nicht wirklich etwas kann und das ja doch echt ein bisschen langweilig w√§re, f√ºgen wir nun noch unsere zwei anfangs geplanten Methoden <code>fahren()</code> und <code>hupen()</code> ein.</p>
                <p>Um mit diesen allerdings nicht den Rahmen zu sprengen, halten wir sie sehr simpel und geben in ihnen nur einen Hinweis in der Konsole aus, dass sie aufgerufen wurden.</p>
                <p>Beide Methoden sollen dabei von au√üen aufgerufen werden k√∂nnen und nichts zur√ºckgeben.</p>
                <p>Damit lautet die Methoden-Definition wie folgt:</p>
                <pre>
                    <code class="JAVA">
    public void fahren(){ 
        System.out.println("Das Model " + this.model + " f√§hrt");
    }

    public void hupen(){
        System.out.println("Das Model " + this.model + " hupt");
    }
                    </code>
                </pre>
                <p>Hier verwenden wir, damit das Beispiel doch ein wenig interessanter wird, ein sehr praktisches Feature von Strings:</p>
                <p>Diese lassen sich n√§mlich unter Verwendung des Pluszeichens (+) sehr einfach zusammenf√ºgen.</p>
                <p>In <code>model</code> ist ja der Modelname des Auto-Objekts als <code>String</code> gespeichert. Damit k√∂nnen wir ihn auch ganz einfach in einen Satz mit einf√ºgen und uns diesen zusammengef√ºgten Satz anschlie√üend in der Konsole anschauen.</p>
                <p>So sieht unsere fertige <code>Auto</code> Klasse nun vervollst√§ndigt wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ 
            this.color = color;
            this.model = model;
        }

        public void fahren(){ 
            System.out.println("Das Model " + this.model + " f√§hrt");
        }
    
        public void hupen(){
            System.out.println("Das Model " + this.model + " hupt");
        }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Das Auto f√§hrt!</h2>
                <p>Mit unserer fertigen <code>Auto</code> Klasse k√∂nnen wir nun also unser erstes richtiges Auto Objekt erstellen.</p>
                <p>Daf√ºr gehen wir nun in die <code>main()</code> Methode der <code>Main</code> Klasse und erstellen in dieser unser Objekt.</p>
                <p>Wie bereits in dem Abschnitt √ºber den Konstruktor im Allgemeinen gezeigt, rufen wir bei der Erstellung eines Objektes einer Klasse den Konstruktor √ºber das Schl√ºsselwort <code>new</code> gefolgt von seinem Namen auf.</p>
                <p>Allerdings ben√∂tigen wir ja zun√§chst erst noch zwei Werte, die wir ihm √ºbergeben k√∂nnen - Die Farbe und den Modelnamen.</p>
                <p>Hierf√ºr m√ºssen wir nun zuerst in die erste Zeile in der <code>Main.java</code> Datei ebenfalls die Klasse <code>Color</code> importieren, da wir ja dem Konstruktor ein Objekt des Typs <code>Color</code> √ºbergeben m√ºssen.</p>
                <p>Dann initialisieren wir einfach zwei Variablen in der <code>main()</code> Methode, <code>farbe</code> vom Typ <code>Color</code> und <code>modelName</code> vom Typ <code>String</code>.</p>
                <p>Diesen k√∂nnen wir dann jeweils einen beliebigen Wert zuweisen. F√ºr <code>modelName</code> suchen wir uns einfach einen Auto-Modelnamen, w√§hrend <code>farbe</code> ja ein Objekt ist, weshalb wir hier den Konstruktor von <code>Color</code> aufrufen und ihm drei Werte f√ºr R, G und B √ºbergeben m√ºssen.</p>
                <p>Diese beiden Variablen √ºbergeben wir dann einfach dem <code>Auto</code> Konstruktor.</p>
                <p>Um anschlie√üend zu √ºberpr√ºfen, ob unser Auto-Objekt auch das tut, was es soll, k√∂nnen wir nun noch √ºber das erstellte Objekt <code>auto1</code> die beiden Methoden <code>fahren()</code> und <code>hupen()</code> aufrufen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Color farbe = new Color(0, 0, 0); // schwarz
            String modelName = "AMG";
            
            Auto auto1 = new Auto(farbe, modelName);
            auto1.fahren();
            auto1.hupen();
        }
    }
                    </code>
                </pre>
                <p>Durch dieses Snippet sollte auch gleich klar werden, wie man Methoden, die als <code>public</code> definiert sind √ºber ein Objekt aufrufen kann.</p>
                <p>Probiere doch einfach mal dir nur den Modelnamen des Autos auf der Konsole ausgeben zu lassen oder ein zweies Auto-Objekt <code>auto2</code> zu erstellen, welches dann allerdings eine andere Frabe und einen anderen Modelnamen haben soll. Rufe dann auch hier die beiden Methoden auf und schau, was auf der Konsole ausgegeben wird.</p>
                <p>Abschlie√üend sei noch gesagt, dass es auch k√ºrzer als in dem Beispiel oben geht, da wir die beiden Variablen <code>farbe</code> und <code>modelName</code> eigentlich nicht ben√∂tigen, sondern deren Werte direkt dem Konstruktor √ºbergeben k√∂nnen.</p>
                <p>Damit l√§sst sich das Programm ein wenig abk√ºrzen:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Auto auto1 = new Auto(new Color(0, 0, 0), "AMG");
            auto1.fahren();
            auto1.hupen();
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Stufe 1</h2>
                <p>Wir beginnen mit dem Erstellen des einfachsten geometrischen Objektes: Dem Punkt. Dabei soll ein jeder Punkt die folgenden Eigenschaften haben:</p>
                <p>Eine <code>x</code> und <code>y</code> Koordinate und eine Darstellungscolor <code>color</code>.</p>
            </div>

            <div class="section">
                <h2>Testen_GPoint.java</h2>
                <p>Eine neue Datei <code>Testen_GPoint.java</code> erstellen, dann den folgenden Quellcode einfach kopieren und einf√ºgen und abschlie√üend <code>Testen_GPoint.java</code> compilieren und ausf√ºhren.</p>
                <p>Wird in der Konsole <code>Test was successful! Good job!</code> ausgegeben, dann funktioniert deine Methode perfekt. Siehst du stattdessen eine rote Fehlermeldung, dann stimmt leider etwas noch nicht ganz mit deiner Methode.</p>
                <pre>
                    <code>
    public class Testen_GPoint {
        private GPoint p;
        public int x, y;
    
        public Testen_GPoint(){
            this.x = 2;
            this.y = 2;
            p = new GPoint(x, y);
        }
    
        public void test() throws Exception {
            if(!(p.abstandZu(4, 4) == this.distanceTo(4, 4))) throw new Exception();
            else System.out.println("Test was successful! Good job!");
        }
    
        public double distanceTo(int mx, int my){
            double dx, dy, d;
            dx = (double) mx - this.x;
            dy = (double) my - this.y;
            d = Math.sqrt(dx * dx + dy * dy);
            return d;
        }
    
        public static void main(String[] args) throws Exception {
            Testen_GPoint pointTest = new Testen_GPoint();
            pointTest.test();
        }
    }
                    </code>
                </pre>
            </div>
            <div class="section">
                <h2>Stufe 5: Neue Punkte erstellen</h2>
                <p>
                    Die Punkte sollen nun ja, nicht wie zum Ende der vorherigen Stufe beschrieben im Konstruktor der Board-Klasse, vom  Benutzer erzeugt werden. So soll bei einem Mausklick ein neues <code>GPoint</code> Objekt (mit den Koordinaten der Stelle des Klicks auf der Zeichenfl√§che) erstellt und in die Liste <code>geoObjects</code> eingef√ºgt werden.                    
                </p>
                <p>
                    Um dieses Mausklick-Event "abzufangen", k√∂nnen wir die Methode <code>Board.mousePressed(MouseEvent e)</code> benutzen. Diese wird von JAVA n√§mlich genau dann aufgerufen, wenn die prim√§re (also die linke) Maustaste gedr√ºckt wurde.
                </p>
                <p>
                    Also schreiben wir in diese <code>mousePressed()</code> Methode unseren Quellcode, der einen neuen Punkt erzeugt und der <code>geoObjects</code> Liste hinzuf√ºgt (Nach demselben Prinzip, wie wir es bereits im Konstruktor von <code>Board</code> gemacht haben).
                </p>
                <p>
                    Zur Initialisierung eines neuen <code>GPoint</code> Objektes ben√∂tigen wir eine x und y Koordinate, die diesem dann "zugewiesen" (In anderen Worten: Dem Konstruktor √ºbergeben) wird. Diese Koordinaten liefert uns der Parameter <code>MouseEvent e</code>. Ganz einfach formuliert √ºbergibt das "System" (Was auch immer hier genau das System sein mag) der <code>mousePressed()</code> Methode ein Objekt vom Typ <code>MouseEvent</code>, in welchem z.B. die Koordinaten des Mauszeigers bei Ausl√∂sung des Events gespeichert sind. 
                </p>
                <p>
                    Um nun in der Methode mit diesen Koordinaten etwas anfangen zu k√∂nnen, die in dem <code>e</code> Objekt (Das ja eigentlich der √ºbergebene Parameter der Methode ist) enthalten sind, benutzen wir folgendes Code-Snippet:
                </p>
                <pre>
                    <code class="JAVA">
    int mx = e.getX();
    int my = e.getY();
                    </code>
                </pre>
                <p>
                    So sind nach diesen beiden Zeilen die x und y Koordinate der Mausposition in <code>mx</code> und <code>my</code> gespeichert.
                </p>
                <div class="exercise">
                    <p>
                        Stelle eine Kopie deines Projekts in einem neuen Verzeichnis <code>GeomObj_D</code> her. Erg√§nze die <code>mousePressed()</code> Methode in der <code>Board</code> Klasse dann so, dass bei einem Mausklick an eine leere Stelle der Zeichnung ein neuer Punkt erzeugt wird.
                    </p>
                    <p>
                        Dieser Punkt muss dann nat√ºrlich auch noch in die <code>geoObjects</code> Liste hinzugef√ºgt werden.
                    </p>
                    <p>
                        Zus√§tzlich sollte nach dem Einf√ºgen eines neuen Punktes das <code>Board</code> neu geladen werden, damit der neue Punkt auch angezeigt wird. Dies l√§sst sich ganz einfach √ºber einen Aufruf der Methode <code>repaint()</code> ganz am Ende deines Codes in der <code>mousePressed()</code> Methode erreichen. Wunder dich nicht, dass du nirgendwo direkt eine Definition dieser <code>repaint()</code> Methode siehst, <code>Board</code> erbt diese n√§mlich von <code>JPanel</code>.
                    </p>
                </div>
                <div class="exercise">
                    <p>
                        Verschiebe den Quellcode f√ºr das Einf√ºgen von Punkten vor√ºbergehend(!) von <code>mousePressed()</code> nach <code>mouseReleased()</code> bzw <code>mouseDragged()</code>. Was √§ndert sich dabei jeweils am Verhalten des Programms?
                    </p>
                    <p>
                        Wenn du etwas mehr wissen m√∂chtest, dann kannst du √ºber den Befehl <code>System.out.println(geoObjects.size());</code> im Konsolenfenster ausgeben lassen, wie gro√ü die <code>geoObjects</code> Liste zum jeweiligen Zeitpunkt ist, d.h. wie viele Punkte schon hinzugef√ºgt wurden.
                        <br>
                        F√ºge diesen daf√ºr einfach in den Methoden <code>mousePressed()</code>, <code>mouseReleased()</code> bzw <code>mouseDragged()</code> ein.
                    </p>
                    <p>
                        Zu guter Letzt musst du nun den verschobenen Quellcode wieder zur√ºck in die <code>mousePressed()</code> Methode verschieben (und ggf. den <code>System.out...</code> Befehl wieder entfernen)
                    </p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 6: Jetzt wird's dynamisch!</h2>
                <p>
                    Nun k√∂nnen wir Punkte per Mausklick hinzuf√ºgen. Allerdings wollen wir nun diese plazierten Punkte auch verschieben k√∂nnen. 
                    Dies regeln wir wie folgt:
                </p>
                <p>
                    Wenn die Maustaste auf einen schon vorhandenen Punkt p (oder hinreichend dicht bei p) gedr√ºckt wird, dann soll dieser Punkt als <code>dragPoint</code>, also als "zu verziehender" Punkt gespeichert werden.
                    Wird nun die Maus bei weiterhin gedr√ºckter Taste bewegt, soll dieser Punkt der Mausbewegung folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Hierf√ºr m√ºssen wir nat√ºrlich erst einmal wissen, ob die Koordinaten des Mauszeigers beim Klicken in der N√§he, bzw. "ganz dicht" an einem bereits existierenden Punkt liegen. 
                </p>
                <p>
                    Dies erledigen wir in der Methode <code>mousePressed()</code> von <code>Board</code>, die ja immer dann aufgerufen wird, wenn die prim√§re Maustaste gedr√ºckt wurde. 
                </p>
                <p>
                    Dann untersuchen wir als erstes einfach alle Punkte der <code>geoObjects</code> Liste darauf, wie dicht sie bei der aktuellen Mausposition liegen. Eine daf√ºr ben√∂tigte Schleife findest du bereits in der <code>Board.paint()</code> Methode oder hier:
                </p>
                <pre>
                    <code class="JAVA">
    for (GPoint p: geoObjects) {
        // Anweisungen hier einf√ºgen
    }                   
                    </code>
                </pre>
                <p>
                    In dieser Schleife ist eine Art "Laufvariable" definiert, <code>p</code> von Typ <code>GPoint</code>. Diese Schleife "l√§uft" √ºber die Liste <code>geoObjects</code> und ihre Laufvariable <code>p</code> nimmt in jedem Durchlauf den Wert an der Stelle der Liste an, an der die Schleife momentan steht.
                    <br>
                    D.h. wenn wir annehmen, dass an der nullten Stelle von <code>geoObjects</code> das Objekt <code>GPoint point1 = new GPoint(1, 1)</code> steht, so w√ºrde die Laufvariable <code>p</code> im allerersten Schleifendurchlauf die Referenz des Objekts <code>point</code> annehmen.
                </p>
                <p>
                    Hier die ganze Erkl√§rung in Code ausgeschrieben:
                </p>
                <pre>
                    <code class="JAVA">
    ArrayList&lt;GPoint&gt; geoObjects = new ArrayList&lt;GPoint&gt;();
    GPoint point1 = new GPoint(1, 1);
    geoObjects.add(point1);
    GPoint point2 = new GPoint(2, 2);
    geoObjects.add(point2);

    for (GPoint p: geoObjects) {
        System.out.println("X: " + p.getX() + "; Y: " + p.getY());
    }                   

    // Gibt in der Konsole aus: 
    // X: 1; Y: 1
    // X: 2; Y: 2
                    </code>
                </pre>
                <p>
                    Wie gro√ü der Abstand zwischen zwei Punkten, also des Punktes <code>p</code> und der aktuellen Mausposition, ist, k√∂nnen wir √ºber einen Aufruf der bereits in Schritt 3 geschriebenen Methode <code>abstandZu()</code> der Klasse <code>GPoint</code> berechnen.
                </p>
                <p>
                    Hierf√ºr √ºbergeben wir dieser Methode einfach die Maus-Koordinaten, welche uns wie bereits in Schritt 5 erw√§hnt, √ºber den Parameter <code>e</code> des Typs <code>MouseEvent</code> √ºbergeben werden: <code>e.getX()</code> und <code>e.getY()</code> geben die jeweilige Koordinate zur√ºck.
                </p>
                <p>
                    Wir erinnern uns: Da die Methode <code>abstandZu()</code> zur Klasse <code>GPoint</code> geh√∂rt und wir sie als <code>public</code> definiert haben, k√∂nnen wir sie √ºber jedes Objekt vom Typ <code>GPoint</code> aufrufen. So dann auch √ºber die Laufvariable <code>p</code> der Schleife, da diese ja vom Typ <code>GPoint</code> ist und in jedem Durchlauf das Element in der <code>geoObjects</code> Liste an der momentanen Stelle in ihr gespeichert wird. Dar√ºber l√§sst sich ganz einfach der Abstand zwischen einem jeden Punkt, der auch ein Element in <code>geoObjects</code> ist und dem Mauscursor berechnen, indem wir √ºber das Objekt <code>p</code> (Die Laufvariable) <code>abstandZu()</code> aufrufen und dieser Methode die Koordinaten des Mauscursors, also <code>e.getX()</code> und <code>e.getY()</code> √ºbergeben.
                </p>
                <p>
                    Dieser Methodenaufruf liefert der Methodendefinition nach einen Wert von Typ <code>double</code>, den Abstand zwischen den beiden Punkten, also genau das, was wir eigentlich brauchen.
                </p>
                <p>
                    Ist der Abstand nun kleiner als 4 (Pixel), so weisen wir der Variablen <code>dragPoint</code> den Punkt p zu; andernfalls beh√§lt <code>dragPoint</code> den Wert <code>null</code> (D.h. wir m√ºssen ihn nicht erneut auf <code>null</code> setzen).
                </p>
                <p>
                    Anschlie√üend √ºberpr√ºfen wir dann, ob <code>dragPoint</code> nicht <code>null</code> ist. Wenn dies der Fall ist, soll dieser Punkt so lange der Maus folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Dies erreichen wir, indem wir in der <code>mouseDragged()</code> Methode den gezogenen Punkt, also <code>draggedPoint</code> stets an die aktuelle Mausposition setzen.
                    <br>
                    Auch in dieser Methode erhalten wir die Koordinaten des Mauszeigers √ºber den √ºbergebenen Parameter <code>e</code> des Typs <code>MouseEvent</code>:
                </p>
                <pre>
                    <code class="JAVA">
    dragPoint.setX(e.getX());
    dragPoint.setY(e.getY());
                    </code>
                </pre>
                <p></p>
                <p>
                    Nun sind zwar die Koordinaten des gezogenen Punktes aktualisiert, jedoch wird diese √Ñnderung noch nicht angezeigt.
                    <br>
                    Auch hier m√ºssen wir die Methode <code>repaint()</code> zum Neuladen, also zum Aktualisieren des Fensters aufrufen.
                </p>
                <p>
                    Was aber, wenn <code>dragPoint</code> gleich <code>null</code> ist? Dann wurde die prim√§re Maustaste an einer freien Stelle des Zeichenbreichs gedr√ºckt. In dieser Situation sollten wir also einen neuen Punkt hinzuf√ºgen - Also genau das tun, was wir bereits in Schritt 5 getan haben! 
                </p>
                <p>
                    Baue also den schon vorhandenen Quelltext zur Erzeugung eines neuen Punktes so in die neue <code>mousePressed()</code> Methode ein, dass er nur noch im Falle <code>dragPoint == null</code> ausgef√ºhrt wird.
                </p>
                <p>
                    Abschlie√üend m√ºssen wir noch den Zugvorgang beim Loslassen der Maustaste beenden. 
                    <br>
                    Hierf√ºr muss einfach in <code>mouseReleased()</code> die Variable <code>dragPoint</code> auf null zu setzen.
                </p>
                <div class="exercise">
                    <p>
                        Erstelle eine Kopie deines Projektes in einem neuen Verzeichnis <code>GeomObj_E</code> und erg√§nze die Maus-Methoden in der Klasse <code>Board</code> wie oben beschrieben.
                    </p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mousePressed()</code> {
                    </p>
                    <p style="padding-left: 20px">if-Schleife ("<i>Ist <code>dragPoint</code> nicht gleich null?</i>") {</p>
                    <p style="padding-left: 40px">for-Schleife {</p>
                    <p style="padding-left: 60px">if-Schleife (" <i> Ist der Abstand zwischen Punkt <code>p</code>(der Laufvariablen der Schleife) und dem Punkt mit den Koordinaten (<code>e.getX()</code>|<code>e.getY()</code>) kleiner als 4?" </i>) { </p>
                    <p style="padding-left: 80px">Setze <code>dragPoint</code></p>
                    <p style="padding-left: 60px">}</p>
                    <p style="padding-left: 40px">}</p>
                    <p style="padding-left: 40px">repaint</p>
                    <p style="padding-left: 20px">}</p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseDragged()</code> {
                    </p>
                    <p style="text-indent: 20px">Setze neue Koordinaten f√ºr <code>dragPoint</code></p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseReleased()</code> {
                    </p>
                    <p style="text-indent: 20px">Reset <code>dragPoint</code> (auf <code>null</code>)</p>
                    <p>}</p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 7: Andere geometrische Objekte: Strecken</h2>
                <p>
                    Nun wollen wir in unserer Applikation ja nicht nur mit Punkten arbeiten, sondern mit "komplexeren" geometrischen Objekten, wie z.B. Strecken.
                </p>
                <p>
                    Hierf√ºr ben√∂tigen wir logischerweise auch gleich eine neue Klasse <code>GLine</code>. 
                </p>
                <p>
                    Genau wie die Punkte, sollen sich auch die Strecken mit Hilfe einer <code>draw()</code> Methode im Zeichenfenster darstellen k√∂nnen.
                </p>
                <p>
                    Strecken haben stets einen Anfangs- und einen Endpunkt und (genau wie die Punkte) eine Farbe, somit ist das folgende UML-Diagramm f√ºr die Strecken naheliegend:
                </p>
                <div class="center">
                    <img src="./assets/dia1.png" alt="" srcset="">
                </div>
                <p>
                    Nun sto√üen wir allerdings schnell auf ein gro√ües Problem: Wenn wir die Klasse <code>GLine</code> fertig implementiert und eine Instanz dieser Klasse, also ein Strecken-Objekt erzeugt h√§tten, m√ºssten wir dieses ja auch in die <code>geoObjects</code> Liste eintragen.
                </p>
                <p>
                    Hier stellt sich jedoch JAVA quer - in die <code>geoObjects</code> Liste k√∂nnen ja nur Objekte vom Typ <code>GPoint</code> hinzugef√ºgt werden. 
                    <br>
                    Gleichzeitig gibt es keine M√∂glichkeit, in einer solchen <code>ArrayList</code> mehrere Objekte von verschiedenen Typen, also mehrere Instanzen verschiedener Klassen zu speichern.
                </p>
                <p>
                    Somit brauchen wir eine Art gemeinsame "Oberklasse" f√ºr <code>GPoint</code> und <code>GLine</code>. Beide Klassen beschreiben ja GeoObjekte, also bietet sich f√ºr den Namen der √ºbergeordneten Oberklasse <code>GeoObjects</code> prima an.
                </p>
                <p>
                    Diese Klasse soll nun alle Eigenschaften (also Attribute) und Methoden beinhalten, die im oberen UML Diagramm sowohl in <code>GPoint</code> und <code>GLine</code> vorhanden sind.
                </p>
                <p>
                    Alle anderen Eigenschaften, in denen sich die beiden Klassen unterscheiden, bleiben damit in ihnen selbst. Damit sind <code>GPoint</code> und <code>GLine</code> jeweils Spezialisierungen von <code>GeoObject</code>.
                </p>
                <p>

                </p>
            </div>
        </div>
    </div>
</body>
</html>