<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoBuilder</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="assets/gb.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="section">
                <h2>Disclaimer</h2>
                <p>Ich besitze keinerlei Rechte an dem folgenden Gedankengut, da dies zu einem Großteil auf der Arbeit vom RP Freiburg und seiner Version dieses ABs basiert.</p>
            </div>
            <div class="section">
                <h2>Basics</h2>
                <p>In diesem Absatz gehe ich so verständlich wie möglich auf einige Basis-Konzepte von Java ein und versuche sie anhand von einfachen Beispiel zu erläutern.</p>
            </div>
            <div class="section">
                <h2>Basics - Das Konzept von objektorientierter Programmierung</h2>
                <p>In objektorientierter Programmierung (Absofort mit OOP abgekürzt) dreht sich alles um <b>Objekte</b>.</p>
                <p>Die erste Frage, die sich einem dann hierbei stellt, ist womöglich: <i>Schön, was aber ist jetzt ein Objekt? Also was kann es und wie macht man eins?</i></p>
                <p>Diese Frage lässt sich am besten mit einem praktischen Beispiel erläutern. Gehen wir nun einmal davon aus, dass wir irgendwie in der Welt des Programmierens in Java ein Auto darstellen wollen.</p>
                <p>Nun, genau für solche Fälle sind Objekte gedacht. Wir betrachten ein Auto nun also nicht einfach nur als Ding, sondern als Objekt. Ein Auto hat bestimmte Eigenschaften und kann bestimmte Dinge tun. Genau so soll also auch ein Objekt funktionieren.</p>
                <p>Die Eigenschaften eines Objektes nennt man hierbei <b>Attribute</b>, während die Fähigkeiten eines Objektes, also die Dinge, die es "tun kann", <b>Methoden</b> genannt werden.</p>
                <p>Wie erstellen wir nun aber ein Auto?</p>
                <p>Genau hier kommen dann <b>Klassen</b> ins Spiel. Eine Klasse kann als Blueprint, als Bauplan für ein Objekt angesehen werden, der genau festlegt, wie ein Objekt einmal auszusehen hat, d.h. was es alles für Eigenschaften und Fähigkeiten haben soll.</p>
                <p>In einer Klasse definieren wir Attribute und Methoden, über die dann ein Objekt dieser Klasse (Auch genannt <b>Instanz</b>) verfügen soll.</p>
                <p>Um das alles einmal praktisch zu veranschaulichen, versuchen wir nun einfach einmal ein sehr einfaches Auto Objekt in Java zu erstellen.</p>
                <p>Hierfür müssen wir uns zu allererst einmal überlegen, welche Eigenschaften und Fähigkeiten ein Auto überhaupt besitzen soll.</p>
                <p>Nun, für unser vereinfachtes Beispiel hat ein Auto auf jeden Fall eine Farbe, einen Modelname und kann hupen und fahren.</p>
                <p>Damit hätten wir zwei Attribute und zwei Fähigkeiten, die ein Auto Objekt also besitzen muss.</p>
                <p>Um nun ein Auto Objekt erstellen zu können, müssen wir erstmal den Bauplan für das Auto, also die Klasse für das Auto entwerfen.</p>
                <p>Diese nennen wir passend <code>Auto</code>.</p>
                <p>Sie soll zwei Attribute, eine Farbe <code>color</code> und einen Modelname <code>modelName</code> und zwei Methoden <code>hupen()</code> und <code>fahren()</code> haben.</p>
            </div>
            <div class="section">
                <h2>Basics - Encapsulation</h2>
                <p>Wir bleiben weiter bei den Beispiel des Autos.</p>
                <p>Um uns nun weiter der Erstellung der <code>Auto</code>-Klasse anzunähern, wenden wir auch gleich ein sehr wichtiges Konzept der OOP an: Encapsulation (DE: Verkapselung).</p>
                <p>In dieser geht es darum die Eigenschaften verschiedener Klassen, also später Objekten, voneinander abzugrenzen. Dies können wir durch die Verwendung von Sichtbarkeits-Modifizierern erreichen. Durch diese legen wir nämlich fest, auf welche Eigenschaften welches Objekt zugreifen kann.</p>
                <p>In Java stehen uns die folgenden zur Verfügung: <code>public</code>, <code>private</code> und <code>protected</code>.</p>
                <p>Der Sichtbarkeits-Modifizierer <code>public</code> bedeutet, dass auf dieses Attribut oder diese Methode direkt von außen zugegriffen werden kann. Das heißt, dass auch von außerhalb des Objektes direkt Änderungen an einem Attribut (das also als <code>public</code> definiert wurde) eines anderen Objektes vorgenommen werden können.</p>
                <p>Das komplette Gegenteil von <code>public</code> ist, wie es der Name schon vermuten lässt, <code>private</code>. Auf ein Attribut, was als <code>private</code> definiert wurde, kann niemals direkt von außerhalb des Objektes darauf zugegriffen werden. Um jedoch immernoch Änderungen an diesem Attribut vornehmen zu können, werden sogenannte <b>Getter</b> und <b>Setter</b> Methoden verwendet.</p>
                <p>Das Praktische an diesen Bezeichnungen ist, dass sie bereits im Vorhinein quasi alles über ihre Funktion verraten.</p>
                <p>Über einen Getter können wir den Wert eines Attributes lesen, ohne dabei direkt von außen auf dieses Attribut zuzugreifen. Wie der Name vermuten lässt, "getten" wir etwas durch ihn - Er gibt etwas zurück, nämlich den Wert des privaten Attributes.</p>
                <p>Ein Setter erlaubt es uns, ihm einen Wert zu übergeben und dann den Wert des entsprechenden Attributes auf diesen übergebenen Wert zu setzen. </p>
                <p>Über diese beiden Umwege können wir also, obwohl wir ein Attribut als <code>private</code> definiert haben, dessen Wert noch ändern. Der wichtige Unterschied hierbei ist, dass wir es in diesem Fall allerdings nicht direkt tun.</p>
                <p>Das gleiche, was ich nun bereits für Attribute erläutert habe, gilt auch für Methoden (nahezu). Bei Methoden weisen wir nun jedoch keinen Wert mehr zu, sondern wollen etwas ausführen, etwas tun.</p>
                <p>Damit regeln die Sichtbarkeits-Modifizierer von Methoden "nur noch", ob auf die jeweiligen Methoden von außerhalb oder nur von innerhalb eines Objektes aus zugegriffen werden kann.</p>
                <p>Ist eine Methode als <code>public</code> definiert, kann auch von außerhalb des Objektes auf die Methode zugegriffen werden. Bei <code>private</code> ist das genaue Gegenteil der Fall.</p>
                <p>Was genau das alles nun im Klartext bedeutet, wird hoffentlich bei der weiteren Ausführung der Erstellung unserer <code>Auto</code> Klasse klar.</p>
                <p>Abschließend sei zu diesem Absatz noch gesagt, dass der Sichtbarkeits-Modifizierer <code>protected</code> eine besondere Funktion hat, auf die ich erst im weiteren Verlauf dieses ABs eingehen werde. Bisher nur soviel: Seine Funktion hat etwas mit einem weiteren extrem wichtigen Konzept der OOP zu tun, der Vererbung. Hierzu jedoch später mehr.</p>
            </div>
            <div class="section">
                <h2>Basics - Methoden</h2>
                <p>Zuvor bin ich bereits auf Methoden im Allgemeinen ein wenig über die Beschreibung der Getter und Setter eingegangen.</p>
                <p>Hierzu sind bestimmt einige Fragen entstanden, die ich nun versuchen werde in diesem Abschnitt zu erläutern.</p>
                <p>Was genau bedeutet es denn, wenn einer Methode ein oder mehrere Werte übergeben werden?</p>
                <p>Um sich das auf eine sehr simple Art zu veranschaulichen, betrachten wir im folgenden eine Methode als eine Art mathematische Funktion.</p>
                <p>In diesem Beispiel sollte dann auch gleich das Konzept einer Methodenrückgabe klarer werden.</p>
                <p>Wir versuchen nun einfach mal (unabhängig zu dem Auto Beispiel aus den zuvorigen Abschnitten!) eine Methode für das Summieren zweier Ganzzahlen zu schreiben.</p>
                <p>Dafür müssen wir, wie bei einer mathematischen Funktion, erst einmal einen oder mehrere Werte in sie "hineinstecken", um einen weiteren "heraus", also zurückzubekommen.</p>
                <p>In Java müssen wir beachten, dass Java es vorschreibt (abgesehen von lambda-Funktionen - doch diese lassen wir in diesem AB außer Acht, bei mehr Interesse gerne direkt bei mir nachfragen), dass jede Funktion in einer Klasse steht und damit im Endeffekt nur über ein Objekt dieser Klasse oder in einem Objekt dieser Klasse aufgerufen werden kann.</p>
                <p>Ferner startet jedes Java-Programm immer in der <code>main</code> Methode, die sich in jedem Java-Programm in der folgenden Form auffinden lässt: </p>
                <pre>
                    <code class="JAVA">
    public static void main(String[] args) {
        // Anweisungen
    }
                    </code>
                </pre>
                <p>Hier finden wir auch gleich einen nun bereits bekannten Sichtbarkeits-Modifizierer, <code>public</code>, der von einem weiteren bisher unbekanntnen Schlüsselwort <code>static</code> und schließlich <code>void</code> gefolgt wird, bis wir schließlich beim Methodennamen <code>main</code> angekommen sind.</p>
                <p>In den Klammern folgt dann ein sogenannter Parameter, <code>args</code> vom Typ <code>String[]</code> (Was genau das nun bedeutet, ist zum jetzigen Stand erst einmal unwichtig). Auf dieses Konzept gehe ich nun im Bezug auf unsere Summen-Methode ein.</p>
                <p>Parameter erlauben es uns, einer Methode Werte von außen zu übergeben, mit denen wir dann etwas in der Methode anstellen können.</p>
                <p>So müssen wir, um das Ergebnis einer Addition von zwei Ganzzahlen zu erhalten, unserer Methode zwei Parameter übergeben: Den ersten und den zweiten Summanden.</p>
                <p>Da wir nur mit ganzen Zahlen rechnen, sollen beide Parameter von Typ <code>int</code> sein und die Namen <code>sum1</code> und <code>sum2</code> haben.</p>
                <p>Diese zwei übergebenen Werte rechnen wir in unserer Methode zusammen und geben das Ergebnis wieder zurück.</p>
                <p>So könnte eine relativ lange Version für unsere Additions-Methode wie folgt aussehen:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        int result = sum1 + sum2;
        return result;
    }
                    </code>
                </pre>
                <p>Wenn wir nun diese Methode einmal mit der <code>main</code> Methode vergleichen, fällt direkt etwas auf: Wo ist das <code>void</code> der <code>main</code> Methode hin?</p>
                <p>Nun, über dieses <code>void</code> sagen wir dem Java-Compiler, dass eine Methode <i>keinen</i> Wert zurückgibt, also genau das, was wir nicht wollen.</p>
                <p>Gerade unsere Additions-Methode soll ja aber das Ergebnis dieser Addition zurückgeben.</p>
                <p>Also müssen wir den Rückgabetypen dieser Methode ändern. Geben wir etwas in einer Methode zurück, müssen wir festlegen, von welchem Typ der zurückgegebene Wert sein wird.</p>
                <p>In unserem Fall wissen wir ja, dass wir nur mit Ganzzahlen, also keinen Kommazahlen rechnen und können demnach den Datentyp <code>int</code> als Rückgabetyp festlegen.</p>
                <p>Und wie geben wir nun einen Wert zurück?</p>
                <p>Dies erledigen wir über die <code>return</code> Anweisung. Der Wert, der ihr folgt, wird zurückgegeben.</p>
                <p>In unserer Additions-Methode geben wir den Wert von der Variablen <code>result</code> des Typs <code>int</code> zurück. In dieser Variablen ist das eigentliche Ergebnis der Addition der beiden Summanden gespeichert.</p>
                <p>Um die Methode ein wenig kürzer zu halten, wäre folgendes auch vollkommen legitim:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        return sum1 + sum2;
    }
                    </code>
                </pre>
                <p>Dann testen wir doch einfach mal unsere Methode!</p>
                <p>Da in Java alles in Klassen stehen muss, müssen wir also erst eine neue Datei erstellen und in dieser eine Klasse definieren, die allerdings keinerlei Eigenschaften besitzen muss. In ihr muss sich nur die <code>main</code> Methode befinden. Denn in dieser startet ja die Ausführung unseres Java-Programms.</p>
                <p>Weiter ist es in Java notwendig die eigentliche Datei so zu nennen, wie die in ihr definierte Klasse heißt.</p>
                <p>Wir nennen unsere "Anfangsklasse" einfach <code>Main</code> und fügen in diese das Code-Snippet der <code>main</code> Methode von weiter oben ein.</p>
                <p>Um im Java-Editor eine leere Java-Datei zu erstellen, klicke auf <code>Datei > Neu > Java</code> oder drücke <code>Strg + N</code></p>
                <p>Um diese Datei dann zu speichern und ihr einen Namen zu geben, klicke auf <code>Datei > Speichern</code> oder drücke <code>Strg + S</code>.</p>
                <p>In dem neu geöffneten Fenster kannst du nun den Speicherort und den Dateinamen festlegen.</p>
                <p>Abschließend einfach auf <code>Speichern</code> klicken.</p>
                <p>Damit sollte in der Datei <code>Main.java</code> nun folgendes stehen:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args){
            int summe = sum(2, 3);
            System.out.println(summe);
        }
    }
                    </code>
                </pre>
                <p>Um nun unsere eigene Methode auszuprobieren, müssen wir diese einfach in die <code>Main</code> Klasse einfügen und (!) das Schlüsselwort <code>static</code> hinzufügen.</p>
                <p>Warum genau dies nun nötig ist würde nun etwas den Rahmen sprengen, deshalb sei lediglich gesagt, dass es notwendig ist und sonst einen Fehler geben würde, weil wir unsere Methode später aus der <code>main</code> Methode und damit aus einem statischen Kontext ausrufen werden, wodurch die aufgerufene Methode automatisch auch als <code>static</code> definiert sein muss.</p>
                <p>Damit sieht die fertige <code>Main</code> Klasse nun so aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }
                    </code>
                </pre>
                <p>Jedoch können wir bisher immer noch nicht sehen, was unsere eigene <code>sum()</code> Methode denn zurückgibt.</p>
                <p>Dafür müssen wir sie ja erstmal irgendwo aufrufen und ihr dabei zwei Werte von Typ <code>int</code> übergeben, denn so haben wir es ja in unserer Methoden-Definition festgelegt.</p>
                <p>Hierfür deklarieren wir in der <code>main()</code> Methode eine Variable <code>addition</code> vom Typ <code>int</code>.</p>
                <p>Anschließend weisen wir ihr einen Wert zu. Jedoch nicht wie bisher direkt eine Zahl, sondern den Wert, den <code>sum()</code> zurückgibt, wenn wir ihr zwei Ganzzahlen übergeben.</p>
                <p>Über den Befehl <code>System.out.println()</code> (Was im übrigen auch einfach nur ein Methoden-Aufruf ist), können wir uns Werte auf der Konsole ausgeben lassen. Nämlich genau den Wert, den wir ihr als Parameter (oder auch Argument genannt) übergeben.</p>
                <p>Damit sieht unser fertiges Additions-Programm wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            int addition;
            addition = sum(2, 3);
            System.out.println(addition);
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }

    // Nach Complilieren und Ausführen wird auf der Konsole ausgegeben:
    // 5
                    </code>
                </pre>
                <p>Versuche doch einfach mal eine Methode <code>mul()</code> für die Multiplikation zweier Ganzzahlen zu schreiben. Oder wie sieht es denn aus, wenn wir drei statt nur zwei Zahlen addieren wollen?</p>
                <p>Probiere einfach ein bisschen herum, das fördert nur dein Verständnis!</p>
            </div>

            <div class="section">
                <h2>Basics - Zurück zur Konstruktion des Autos</h2>
                <p>Nun mit unserem neuen Wissen wollen wir das Beispiel von einem Auto Objekt einmal zuende führen.</p>
                <p>Um einmal zu rekapitulieren:</p>
                <ul>
                    <li>Unser Auto Objekt soll folgende Attribute und Methoden besitzen: <code>color</code>, <code>model</code>, <code>fahren()</code> und <code>hupen()</code></li>
                    <li>Nach dem Konzept der Encapsulation müssen wir uns nun überlegen, welche Attribute und Methoden nach außen sichtbar sein sollen und welche nicht. In anderen Worten: Auf welche Eigenschaften von außen zugegriffen werden kann.</li>
                    <li>Zusätzlich müssen wir auch erst einmal überlegen, was genau wir in den Attributen speichern wollen. Daraus legen wir dann die entsprechenden Datentypen fest.</li>
                </ul>
                <p>Was muss denn nun alles von außen direkt aufrufbar sein?</p>
                <p>Nun, <code>color</code>, <code>model</code> müssen ja eigentlich nicht wirklich direkt von außen abrufbar sein. Eventuell wollen wir sie im Laufe des Programmes einmal auslesen oder sogar ändern, ein Auto kann ja auch neu lackiert werden und das können wir dann ja über den indirekten Zugriff über die Getter und Setter regeln.</p>
                <p>Das heißt, dass wir <code>color</code> und <code>model</code> auf jeden Fall als <code>private</code> definieren werden.</p>
                <p>Bleibt noch die Frage des Datentyps.</p>
                <p>Der einfachere Fall zuerst: In <code>model</code> wollen wir ja einen Modelnamen speichern. Und aus was besteht ein Name? Genau, aus vielen aneinandergehängten Zeichen. Damit fällt unsere Wahl des Datentyps von <code>model</code> eindeutig auf <code>String</code>, da sich in einem <code>String</code> Zeichenketten speichern lassen.</p>
                <p>In <code>color</code> soll ja eine Farbe gespeichert werden. Dies könnten wir zwar ganz einfach durch eine Zeichenkette, also einen <code>String</code> realisieren, indem wir z.B. einfach den hex-code einer Farbe als <code>String</code> in <code>color</code> speichern, jedoch ist das relativ unpraktisch.</p>
                <p>Da kommt es uns nur gelegen, dass Java bereits eine eigene Klasse <code>Color</code> definiert hat, die es uns erlaubt simpel <code>Color</code> Objekte zu erstellen, in denen wir dann die Werte für R (Rot), G (Grün) und B (Blau) speichern können und uns zusätzlich noch einige andere sehr praktische Methoden zur Verfügung stehen.</p>
                <p>Wichtig hierbei ist noch, dass wir, um diese Klasse in unserem Quellcode verwenden zu können, sie erst über den folgenden Befehl, den wir später ganz oben in die erste Zeile unseres Programms schreiben, importieren müssen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;
                    </code>
                </pre>
                <p>Um ein Objekt <code>color</code> des Typs <code>Color</code> zu erstellen, verwenden wir folgendes Code-Snippet:</p>
                <pre>
                    <code class="JAVA">
    Color color = new Color(255, 0, 0);
                    </code>
                </pre>
                <p>Bevor ich nun genauer auf die Erklärung dieses Snippets eingehe, erst noch ein paar Worte zu der Formulierung "<i>Ein Objekt ... des Typs ...</i>":</p>
                <p>Mit dieser Formulierung lässt sich ausdrücken mithilfe welcher Klasse ein Objekt erstellt wird.</p>
                <p>So bedeutet in unserem Fall "<i>ein Objekt <code>color</code> des Typs <code>Color</code></i>", dass das Objekt <code>color</code> durch die Klasse <code>Color</code> festgelegt und sie damit also der Bauplan für das Objekt ist.</p>
                <p>In ihr steht also genau definiert, welche Eigenschaften und Fähigkeiten, also Attribute und Methoden ein Farb-Objekt haben sollte.</p>
                <p>Jetzt aber mal zur richtigen Erklärung des Snippets:</p>
                <p>Bisher sind wir nur darauf eingegangen, was eine Klasse eigentlich ist und wofür wir sie benötigen. Die Frage, wie wir denn nun ein Objekt nach dem Bauplan, den die Klasse vorgibt, erstellen ist allerdings immer noch offen.</p>
                <p>Das magische Wort lautet hier <b>Konstruktor</b>.</p>
                <p>Was ist nun aber ein Konstruktor?</p>
                <p>Jede Klasse muss über eine Methode verfügen, die bei der Erzeugung eines Objekts der Klasse aufgerufen wird. In dieser Methode können dann Werte initialisiert und erste Anweisungen durchgeführt werden. Diese Methode heißt Konstruktor.</p>
                <p>Er wird bei der Erstellung, also bei der Konstruktion eines Objekts aufgerufen.</p>
                <p>Für ihn gibt es ein paar Sonderregeln, die immer gelten:</p>
                <p>Die wichtigste davon ist dabei mit Sicherheit die folgende: Der Konstruktor muss immer in jeder Klasse ohne Ausnahme wie die Klasse benannt sein.</p>
                <p>Gleichzeitig muss er immer als <code>public</code> definiert werden, da er ja von außerhalb eines Objektes aufgerufen wird.</p>
                <p>Eine weitere Besonderheit ist, dass ein Konstruktor niemals einen Rückgabetyp hat, in seiner Definition also nie ein <code>void</code> oder ein Datentyp stehen darf.</p>
                <p>Im Großen und Ganzen ist der Konstruktor aber eben auch nur eine Methode.</p>
                <p>Das heißt für ihn gelten mit den paar zuvor genannten Einschränkungen, exakt dieselben Regel wir für jede andere beliebige Methode.</p>
                <p>Also können wir auch einem Konstruktor bestimmte Parameter übergeben, mit denen wir dann etwas in ihm anstellen können.</p>
                <p>So wollen wir ja schon bei der Erstellung eines Auto-Objektes unsere eigenen Farbe und den Modelnamen individuell festlegen lassen.</p>
                <p>Mit diesem ganzen neuen Wissen ist es uns nun sogar schon möglich eine erste Version (bisher ohne weitere Methoden, als den Konstruktor) der Klasse <code>Auto</code> zu entwerfen.</p>
                <p>Um es einmal davor noch kurz und knapp zusammenzufassen:</p>
                <ul>
                    <li>Die Klasse soll die zwei Attribute <code>color</code> und <code>model</code> besitzen, die beide als <code>private</code> definiert werden. Dabei hat <code>color</code> den Datentyp <code>Color</code> und <code>model</code> den bereits bekannten Datentyp <code>String</code>.</li>
                    <li>Außerdem benötigt sie einen Konstruktor, der den gleichen Namen wie sie selbst hat - Also <code>Auto()</code> - und als <code>public</code> definiert ist. <br> Außerdem soll er die beiden Parameter <code>color</code> vom Typ <code>Color</code> und <code>model</code> vom Typ <code>String</code> entgegennehmen.</li>
                </ul>
                <p>Damit sieht unser erster Entwurf der <code>Auto</code> Klasse wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }
    }
                    </code>
                </pre>
                <p>Hierbei sei noch zu beachten, dass die Attribute bei ihrer Deklaration nicht direkt mit einem Wert initialisiert werden, sondern dies in dem Konstruktor geschieht.</p>
                <p>Eine Außnahme hierfür stellen konstante Attribute dar, da diese immer direkt in ihrer Deklaration initialisiert werden müssen. Anschließend kann ihr Wert jedoch auch an keinem Punkt in unserem Programm abgeändert werden.</p>
                <p>Würden wir zum Beispiel davon ausgehen, dass die Räderanzahl eines Autos immer nur gleich 4 sein sollte, so könnten wir das folgende Attribut einfügen:</p>
                <pre>
                    <code class="JAVA">
    private final int tires = 4;
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Stufe 1</h2>
                <p>Wir beginnen mit dem Erstellen des einfachsten geometrischen Objektes: Dem Punkt. Dabei soll ein jeder Punkt die folgenden Eigenschaften haben:</p>
                <p>Eine <code>x</code> und <code>y</code> Koordinate und eine Darstellungscolor <code>color</code>.</p>
            </div>

            <div class="section">
                <h2>Testen_GPoint.java</h2>
                <p>Eine neue Datei <code>Testen_GPoint.java</code> erstellen, dann den folgenden Quellcode einfach kopieren und einfügen und abschließend <code>Testen_GPoint.java</code> compilieren und ausführen.</p>
                <p>Wird in der Konsole <code>Test was successful! Good job!</code> ausgegeben, dann funktioniert deine Methode perfekt. Siehst du stattdessen eine rote Fehlermeldung, dann stimmt leider etwas noch nicht ganz mit deiner Methode.</p>
                <pre>
                    <code>
    public class Testen_GPoint {
        private GPoint p;
        public int x, y;
    
        public Testen_GPoint(){
            this.x = 2;
            this.y = 2;
            p = new GPoint(x, y);
        }
    
        public void test() throws Exception {
            if(!(p.abstandZu(4, 4) == this.distanceTo(4, 4))) throw new Exception();
            else System.out.println("Test was successful! Good job!");
        }
    
        public double distanceTo(int mx, int my){
            double dx, dy, d;
            dx = (double) mx - this.x;
            dy = (double) my - this.y;
            d = Math.sqrt(dx * dx + dy * dy);
            return d;
        }
    
        public static void main(String[] args) throws Exception {
            Testen_GPoint pointTest = new Testen_GPoint();
            pointTest.test();
        }
    }
                    </code>
                </pre>
            </div>
            <div class="section">
                <h2>Stufe 5: Neue Punkte erstellen</h2>
                <p>
                    Die Punkte sollen nun ja, nicht wie zum Ende der vorherigen Stufe beschrieben im Konstruktor der Board-Klasse, vom  Benutzer erzeugt werden. So soll bei einem Mausklick ein neues <code>GPoint</code> Objekt (mit den Koordinaten der Stelle des Klicks auf der Zeichenfläche) erstellt und in die Liste <code>geoObjects</code> eingefügt werden.                    
                </p>
                <p>
                    Um dieses Mausklick-Event "abzufangen", können wir die Methode <code>Board.mousePressed(MouseEvent e)</code> benutzen. Diese wird von JAVA nämlich genau dann aufgerufen, wenn die primäre (also die linke) Maustaste gedrückt wurde.
                </p>
                <p>
                    Also schreiben wir in diese <code>mousePressed()</code> Methode unseren Quellcode, der einen neuen Punkt erzeugt und der <code>geoObjects</code> Liste hinzufügt (Nach demselben Prinzip, wie wir es bereits im Konstruktor von <code>Board</code> gemacht haben).
                </p>
                <p>
                    Zur Initialisierung eines neuen <code>GPoint</code> Objektes benötigen wir eine x und y Koordinate, die diesem dann "zugewiesen" (In anderen Worten: Dem Konstruktor übergeben) wird. Diese Koordinaten liefert uns der Parameter <code>MouseEvent e</code>. Ganz einfach formuliert übergibt das "System" (Was auch immer hier genau das System sein mag) der <code>mousePressed()</code> Methode ein Objekt vom Typ <code>MouseEvent</code>, in welchem z.B. die Koordinaten des Mauszeigers bei Auslösung des Events gespeichert sind. 
                </p>
                <p>
                    Um nun in der Methode mit diesen Koordinaten etwas anfangen zu können, die in dem <code>e</code> Objekt (Das ja eigentlich der übergebene Parameter der Methode ist) enthalten sind, benutzen wir folgendes Code-Snippet:
                </p>
                <pre>
                    <code class="JAVA">
    int mx = e.getX();
    int my = e.getY();
                    </code>
                </pre>
                <p>
                    So sind nach diesen beiden Zeilen die x und y Koordinate der Mausposition in <code>mx</code> und <code>my</code> gespeichert.
                </p>
                <div class="exercise">
                    <p>
                        Stelle eine Kopie deines Projekts in einem neuen Verzeichnis <code>GeomObj_D</code> her. Ergänze die <code>mousePressed()</code> Methode in der <code>Board</code> Klasse dann so, dass bei einem Mausklick an eine leere Stelle der Zeichnung ein neuer Punkt erzeugt wird.
                    </p>
                    <p>
                        Dieser Punkt muss dann natürlich auch noch in die <code>geoObjects</code> Liste hinzugefügt werden.
                    </p>
                    <p>
                        Zusätzlich sollte nach dem Einfügen eines neuen Punktes das <code>Board</code> neu geladen werden, damit der neue Punkt auch angezeigt wird. Dies lässt sich ganz einfach über einen Aufruf der Methode <code>repaint()</code> ganz am Ende deines Codes in der <code>mousePressed()</code> Methode erreichen. Wunder dich nicht, dass du nirgendwo direkt eine Definition dieser <code>repaint()</code> Methode siehst, <code>Board</code> erbt diese nämlich von <code>JPanel</code>.
                    </p>
                </div>
                <div class="exercise">
                    <p>
                        Verschiebe den Quellcode für das Einfügen von Punkten vorübergehend(!) von <code>mousePressed()</code> nach <code>mouseReleased()</code> bzw <code>mouseDragged()</code>. Was ändert sich dabei jeweils am Verhalten des Programms?
                    </p>
                    <p>
                        Wenn du etwas mehr wissen möchtest, dann kannst du über den Befehl <code>System.out.println(geoObjects.size());</code> im Konsolenfenster ausgeben lassen, wie groß die <code>geoObjects</code> Liste zum jeweiligen Zeitpunkt ist, d.h. wie viele Punkte schon hinzugefügt wurden.
                        <br>
                        Füge diesen dafür einfach in den Methoden <code>mousePressed()</code>, <code>mouseReleased()</code> bzw <code>mouseDragged()</code> ein.
                    </p>
                    <p>
                        Zu guter Letzt musst du nun den verschobenen Quellcode wieder zurück in die <code>mousePressed()</code> Methode verschieben (und ggf. den <code>System.out...</code> Befehl wieder entfernen)
                    </p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 6: Jetzt wird's dynamisch!</h2>
                <p>
                    Nun können wir Punkte per Mausklick hinzufügen. Allerdings wollen wir nun diese plazierten Punkte auch verschieben können. 
                    Dies regeln wir wie folgt:
                </p>
                <p>
                    Wenn die Maustaste auf einen schon vorhandenen Punkt p (oder hinreichend dicht bei p) gedrückt wird, dann soll dieser Punkt als <code>dragPoint</code>, also als "zu verziehender" Punkt gespeichert werden.
                    Wird nun die Maus bei weiterhin gedrückter Taste bewegt, soll dieser Punkt der Mausbewegung folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Hierfür müssen wir natürlich erst einmal wissen, ob die Koordinaten des Mauszeigers beim Klicken in der Nähe, bzw. "ganz dicht" an einem bereits existierenden Punkt liegen. 
                </p>
                <p>
                    Dies erledigen wir in der Methode <code>mousePressed()</code> von <code>Board</code>, die ja immer dann aufgerufen wird, wenn die primäre Maustaste gedrückt wurde. 
                </p>
                <p>
                    Dann untersuchen wir als erstes einfach alle Punkte der <code>geoObjects</code> Liste darauf, wie dicht sie bei der aktuellen Mausposition liegen. Eine dafür benötigte Schleife findest du bereits in der <code>Board.paint()</code> Methode oder hier:
                </p>
                <pre>
                    <code class="JAVA">
    for (GPoint p: geoObjects) {
        // Anweisungen hier einfügen
    }                   
                    </code>
                </pre>
                <p>
                    In dieser Schleife ist eine Art "Laufvariable" definiert, <code>p</code> von Typ <code>GPoint</code>. Diese Schleife "läuft" über die Liste <code>geoObjects</code> und ihre Laufvariable <code>p</code> nimmt in jedem Durchlauf den Wert an der Stelle der Liste an, an der die Schleife momentan steht.
                    <br>
                    D.h. wenn wir annehmen, dass an der nullten Stelle von <code>geoObjects</code> das Objekt <code>GPoint point1 = new GPoint(1, 1)</code> steht, so würde die Laufvariable <code>p</code> im allerersten Schleifendurchlauf die Referenz des Objekts <code>point</code> annehmen.
                </p>
                <p>
                    Hier die ganze Erklärung in Code ausgeschrieben:
                </p>
                <pre>
                    <code class="JAVA">
    ArrayList&lt;GPoint&gt; geoObjects = new ArrayList&lt;GPoint&gt;();
    GPoint point1 = new GPoint(1, 1);
    geoObjects.add(point1);
    GPoint point2 = new GPoint(2, 2);
    geoObjects.add(point2);

    for (GPoint p: geoObjects) {
        System.out.println("X: " + p.getX() + "; Y: " + p.getY());
    }                   

    // Gibt in der Konsole aus: 
    // X: 1; Y: 1
    // X: 2; Y: 2
                    </code>
                </pre>
                <p>
                    Wie groß der Abstand zwischen zwei Punkten, also des Punktes <code>p</code> und der aktuellen Mausposition, ist, können wir über einen Aufruf der bereits in Schritt 3 geschriebenen Methode <code>abstandZu()</code> der Klasse <code>GPoint</code> berechnen.
                </p>
                <p>
                    Hierfür übergeben wir dieser Methode einfach die Maus-Koordinaten, welche uns wie bereits in Schritt 5 erwähnt, über den Parameter <code>e</code> des Typs <code>MouseEvent</code> übergeben werden: <code>e.getX()</code> und <code>e.getY()</code> geben die jeweilige Koordinate zurück.
                </p>
                <p>
                    Wir erinnern uns: Da die Methode <code>abstandZu()</code> zur Klasse <code>GPoint</code> gehört und wir sie als <code>public</code> definiert haben, können wir sie über jedes Objekt vom Typ <code>GPoint</code> aufrufen. So dann auch über die Laufvariable <code>p</code> der Schleife, da diese ja vom Typ <code>GPoint</code> ist und in jedem Durchlauf das Element in der <code>geoObjects</code> Liste an der momentanen Stelle in ihr gespeichert wird. Darüber lässt sich ganz einfach der Abstand zwischen einem jeden Punkt, der auch ein Element in <code>geoObjects</code> ist und dem Mauscursor berechnen, indem wir über das Objekt <code>p</code> (Die Laufvariable) <code>abstandZu()</code> aufrufen und dieser Methode die Koordinaten des Mauscursors, also <code>e.getX()</code> und <code>e.getY()</code> übergeben.
                </p>
                <p>
                    Dieser Methodenaufruf liefert der Methodendefinition nach einen Wert von Typ <code>double</code>, den Abstand zwischen den beiden Punkten, also genau das, was wir eigentlich brauchen.
                </p>
                <p>
                    Ist der Abstand nun kleiner als 4 (Pixel), so weisen wir der Variablen <code>dragPoint</code> den Punkt p zu; andernfalls behält <code>dragPoint</code> den Wert <code>null</code> (D.h. wir müssen ihn nicht erneut auf <code>null</code> setzen).
                </p>
                <p>
                    Anschließend überprüfen wir dann, ob <code>dragPoint</code> nicht <code>null</code> ist. Wenn dies der Fall ist, soll dieser Punkt so lange der Maus folgen, bis die Maustaste wieder losgelassen wird.
                </p>
                <p>
                    Dies erreichen wir, indem wir in der <code>mouseDragged()</code> Methode den gezogenen Punkt, also <code>draggedPoint</code> stets an die aktuelle Mausposition setzen.
                    <br>
                    Auch in dieser Methode erhalten wir die Koordinaten des Mauszeigers über den übergebenen Parameter <code>e</code> des Typs <code>MouseEvent</code>:
                </p>
                <pre>
                    <code class="JAVA">
    dragPoint.setX(e.getX());
    dragPoint.setY(e.getY());
                    </code>
                </pre>
                <p></p>
                <p>
                    Nun sind zwar die Koordinaten des gezogenen Punktes aktualisiert, jedoch wird diese Änderung noch nicht angezeigt.
                    <br>
                    Auch hier müssen wir die Methode <code>repaint()</code> zum Neuladen, also zum Aktualisieren des Fensters aufrufen.
                </p>
                <p>
                    Was aber, wenn <code>dragPoint</code> gleich <code>null</code> ist? Dann wurde die primäre Maustaste an einer freien Stelle des Zeichenbreichs gedrückt. In dieser Situation sollten wir also einen neuen Punkt hinzufügen - Also genau das tun, was wir bereits in Schritt 5 getan haben! 
                </p>
                <p>
                    Baue also den schon vorhandenen Quelltext zur Erzeugung eines neuen Punktes so in die neue <code>mousePressed()</code> Methode ein, dass er nur noch im Falle <code>dragPoint == null</code> ausgeführt wird.
                </p>
                <p>
                    Abschließend müssen wir noch den Zugvorgang beim Loslassen der Maustaste beenden. 
                    <br>
                    Hierfür muss einfach in <code>mouseReleased()</code> die Variable <code>dragPoint</code> auf null zu setzen.
                </p>
                <div class="exercise">
                    <p>
                        Erstelle eine Kopie deines Projektes in einem neuen Verzeichnis <code>GeomObj_E</code> und ergänze die Maus-Methoden in der Klasse <code>Board</code> wie oben beschrieben.
                    </p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mousePressed()</code> {
                    </p>
                    <p style="padding-left: 20px">if-Schleife ("<i>Ist <code>dragPoint</code> nicht gleich null?</i>") {</p>
                    <p style="padding-left: 40px">for-Schleife {</p>
                    <p style="padding-left: 60px">if-Schleife (" <i> Ist der Abstand zwischen Punkt <code>p</code>(der Laufvariablen der Schleife) und dem Punkt mit den Koordinaten (<code>e.getX()</code>|<code>e.getY()</code>) kleiner als 4?" </i>) { </p>
                    <p style="padding-left: 80px">Setze <code>dragPoint</code></p>
                    <p style="padding-left: 60px">}</p>
                    <p style="padding-left: 40px">}</p>
                    <p style="padding-left: 40px">repaint</p>
                    <p style="padding-left: 20px">}</p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseDragged()</code> {
                    </p>
                    <p style="text-indent: 20px">Setze neue Koordinaten für <code>dragPoint</code></p>
                    <p>}</p>
                </div>
                <div class="tipp" style="font-family: monospace !important">
                    <p>
                        In <code>mouseReleased()</code> {
                    </p>
                    <p style="text-indent: 20px">Reset <code>dragPoint</code> (auf <code>null</code>)</p>
                    <p>}</p>
                </div>
            </div>
            <div class="section">
                <h2>Stufe 7: Andere geometrische Objekte: Strecken</h2>
                <p>
                    Nun wollen wir in unserer Applikation ja nicht nur mit Punkten arbeiten, sondern mit "komplexeren" geometrischen Objekten, wie z.B. Strecken.
                </p>
                <p>
                    Hierfür benötigen wir logischerweise auch gleich eine neue Klasse <code>GLine</code>. 
                </p>
                <p>
                    Genau wie die Punkte, sollen sich auch die Strecken mit Hilfe einer <code>draw()</code> Methode im Zeichenfenster darstellen können.
                </p>
                <p>
                    Strecken haben stets einen Anfangs- und einen Endpunkt und (genau wie die Punkte) eine Farbe, somit ist das folgende UML-Diagramm für die Strecken naheliegend:
                </p>
                <div class="center">
                    <img src="./assets/dia1.png" alt="" srcset="">
                </div>
                <p>
                    Nun stoßen wir allerdings schnell auf ein großes Problem: Wenn wir die Klasse <code>GLine</code> fertig implementiert und eine Instanz dieser Klasse, also ein Strecken-Objekt erzeugt hätten, müssten wir dieses ja auch in die <code>geoObjects</code> Liste eintragen.
                </p>
                <p>
                    Hier stellt sich jedoch JAVA quer - in die <code>geoObjects</code> Liste können ja nur Objekte vom Typ <code>GPoint</code> hinzugefügt werden. 
                    <br>
                    Gleichzeitig gibt es keine Möglichkeit, in einer solchen <code>ArrayList</code> mehrere Objekte von verschiedenen Typen, also mehrere Instanzen verschiedener Klassen zu speichern.
                </p>
                <p>
                    Somit brauchen wir eine Art gemeinsame "Oberklasse" für <code>GPoint</code> und <code>GLine</code>. Beide Klassen beschreiben ja GeoObjekte, also bietet sich für den Namen der übergeordneten Oberklasse <code>GeoObjects</code> prima an.
                </p>
                <p>
                    Diese Klasse soll nun alle Eigenschaften (also Attribute) und Methoden beinhalten, die im oberen UML Diagramm sowohl in <code>GPoint</code> und <code>GLine</code> vorhanden sind.
                </p>
                <p>
                    Alle anderen Eigenschaften, in denen sich die beiden Klassen unterscheiden, bleiben damit in ihnen selbst. Damit sind <code>GPoint</code> und <code>GLine</code> jeweils Spezialisierungen von <code>GeoObject</code>.
                </p>
                <p>

                </p>
            </div>
        </div>
    </div>
</body>
</html>