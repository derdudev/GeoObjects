<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java Basics</title>
    <link rel="stylesheet" href="style.css">
    <link rel="shortcut icon" href="assets/gb.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <div class="page">
            <div class="basics">
                <div class="icon">INFO</div>
                <p>Zur Haupt-Section (AB) geht es hier: <a href="/index.html">Arbeitsblatt</a>.</p>
            </div>
            <div class="section">
                <h2>Basics</h2>
                <p>In diesem Absatz gehe ich so verst√§ndlich wie m√∂glich auf einige Basis-Konzepte von Java ein und versuche sie anhand von einfachen Beispiel zu erl√§utern.</p>
            </div>
            <div class="section">
                <h2>Basics - Das Konzept von objektorientierter Programmierung</h2>
                <p>In objektorientierter Programmierung (Absofort mit OOP abgek√ºrzt) dreht sich alles um <b>Objekte</b>.</p>
                <p>Die erste Frage, die sich einem dann hierbei stellt, ist wom√∂glich: <i>Sch√∂n, was aber ist jetzt ein Objekt? Also was kann es und wie macht man eins?</i></p>
                <p>Diese Frage l√§sst sich am besten mit einem praktischen Beispiel erl√§utern. Gehen wir nun einmal davon aus, dass wir irgendwie in der Welt des Programmierens in Java ein Auto darstellen wollen.</p>
                <p>Nun, genau f√ºr solche F√§lle sind Objekte gedacht. Wir betrachten ein Auto nun also nicht einfach nur als Ding, sondern als Objekt. Ein Auto hat bestimmte Eigenschaften und kann bestimmte Dinge tun. Genau so soll also auch ein Objekt funktionieren.</p>
                <p>Die Eigenschaften eines Objektes nennt man hierbei <b>Attribute</b>, w√§hrend die F√§higkeiten eines Objektes, also die Dinge, die es "tun kann", <b>Methoden</b> genannt werden.</p>
                <p>Wie erstellen wir nun aber ein Auto?</p>
                <p>Genau hier kommen dann <b>Klassen</b> ins Spiel. Eine Klasse kann als Blueprint, als Bauplan f√ºr ein Objekt angesehen werden, der genau festlegt, wie ein Objekt einmal auszusehen hat, d.h. was es alles f√ºr Eigenschaften und F√§higkeiten haben soll.</p>
                <p>In einer Klasse definieren wir Attribute und Methoden, √ºber die dann ein Objekt dieser Klasse (Auch genannt <b>Instanz</b>) verf√ºgen soll.</p>
                <p>Um das alles einmal praktisch zu veranschaulichen, versuchen wir nun einfach einmal ein sehr einfaches Auto Objekt in Java zu erstellen.</p>
                <p>Hierf√ºr m√ºssen wir uns zu allererst einmal √ºberlegen, welche Eigenschaften und F√§higkeiten ein Auto √ºberhaupt besitzen soll.</p>
                <p>Nun, f√ºr unser vereinfachtes Beispiel hat ein Auto auf jeden Fall eine Farbe, einen Modelname und kann hupen und fahren.</p>
                <p>Damit h√§tten wir zwei Attribute und zwei F√§higkeiten, die ein Auto Objekt also besitzen muss.</p>
                <p>Um nun ein Auto Objekt erstellen zu k√∂nnen, m√ºssen wir erstmal den Bauplan f√ºr das Auto, also die Klasse f√ºr das Auto entwerfen.</p>
                <p>Diese nennen wir passend <code>Auto</code>.</p>
                <p>Sie soll zwei Attribute, eine Farbe <code>color</code> und einen Modelname <code>modelName</code> und zwei Methoden <code>hupen()</code> und <code>fahren()</code> haben.</p>
            </div>
            <div class="section">
                <h2>Basics - Encapsulation</h2>
                <p>Wir bleiben weiter bei den Beispiel des Autos.</p>
                <p>Um uns nun weiter der Erstellung der <code>Auto</code>-Klasse anzun√§hern, wenden wir auch gleich ein sehr wichtiges Konzept der OOP an: Encapsulation (DE: Verkapselung).</p>
                <p>In dieser geht es darum die Eigenschaften verschiedener Klassen, also sp√§ter Objekten, voneinander abzugrenzen. Dies k√∂nnen wir durch die Verwendung von Sichtbarkeits-Modifizierern erreichen. Durch diese legen wir n√§mlich fest, auf welche Eigenschaften welches Objekt zugreifen kann.</p>
                <p>In Java stehen uns die folgenden zur Verf√ºgung: <code>public</code>, <code>private</code> und <code>protected</code>.</p>
                <p>Der Sichtbarkeits-Modifizierer <code>public</code> bedeutet, dass auf dieses Attribut oder diese Methode direkt von au√üen zugegriffen werden kann. Das hei√üt, dass auch von au√üerhalb des Objektes direkt √Ñnderungen an einem Attribut (das also als <code>public</code> definiert wurde) eines anderen Objektes vorgenommen werden k√∂nnen.</p>
                <p>Das komplette Gegenteil von <code>public</code> ist, wie es der Name schon vermuten l√§sst, <code>private</code>. Auf ein Attribut, was als <code>private</code> definiert wurde, kann niemals direkt von au√üerhalb des Objektes darauf zugegriffen werden. Um jedoch immernoch √Ñnderungen an diesem Attribut vornehmen zu k√∂nnen, werden sogenannte <b>Getter</b> und <b>Setter</b> Methoden verwendet.</p>
                <p>Das Praktische an diesen Bezeichnungen ist, dass sie bereits im Vorhinein quasi alles √ºber ihre Funktion verraten.</p>
                <p>√úber einen Getter k√∂nnen wir den Wert eines Attributes lesen, ohne dabei direkt von au√üen auf dieses Attribut zuzugreifen. Wie der Name vermuten l√§sst, "getten" wir etwas durch ihn - Er gibt etwas zur√ºck, n√§mlich den Wert des privaten Attributes.</p>
                <p>Ein Setter erlaubt es uns, ihm einen Wert zu √ºbergeben und dann den Wert des entsprechenden Attributes auf diesen √ºbergebenen Wert zu setzen. </p>
                <p>√úber diese beiden Umwege k√∂nnen wir also, obwohl wir ein Attribut als <code>private</code> definiert haben, dessen Wert noch √§ndern. Der wichtige Unterschied hierbei ist, dass wir es in diesem Fall allerdings nicht direkt tun.</p>
                <p>Das gleiche, was ich nun bereits f√ºr Attribute erl√§utert habe, gilt auch f√ºr Methoden (nahezu). Bei Methoden weisen wir nun jedoch keinen Wert mehr zu, sondern wollen etwas ausf√ºhren, etwas tun.</p>
                <p>Damit regeln die Sichtbarkeits-Modifizierer von Methoden "nur noch", ob auf die jeweiligen Methoden von au√üerhalb oder nur von innerhalb eines Objektes aus zugegriffen werden kann.</p>
                <p>Ist eine Methode als <code>public</code> definiert, kann auch von au√üerhalb des Objektes auf die Methode zugegriffen werden. Bei <code>private</code> ist das genaue Gegenteil der Fall.</p>
                <p>Was genau das alles nun im Klartext bedeutet, wird hoffentlich bei der weiteren Ausf√ºhrung der Erstellung unserer <code>Auto</code> Klasse klar.</p>
                <p>Abschlie√üend sei zu diesem Absatz noch gesagt, dass der Sichtbarkeits-Modifizierer <code>protected</code> eine besondere Funktion hat, auf die ich erst im weiteren Verlauf dieses ABs eingehen werde. Bisher nur soviel: Seine Funktion hat etwas mit einem weiteren extrem wichtigen Konzept der OOP zu tun, der Vererbung. Hierzu jedoch sp√§ter mehr.</p>
            </div>
            <div class="section">
                <h2>Basics - Methoden</h2>
                <p>Zuvor bin ich bereits auf Methoden im Allgemeinen ein wenig √ºber die Beschreibung der Getter und Setter eingegangen.</p>
                <p>Hierzu sind bestimmt einige Fragen entstanden, die ich nun versuchen werde in diesem Abschnitt zu erl√§utern.</p>
                <p>Was genau bedeutet es denn, wenn einer Methode ein oder mehrere Werte √ºbergeben werden?</p>
                <p>Um sich das auf eine sehr simple Art zu veranschaulichen, betrachten wir im folgenden eine Methode als eine Art mathematische Funktion.</p>
                <p>In diesem Beispiel sollte dann auch gleich das Konzept einer Methodenr√ºckgabe klarer werden.</p>
                <p>Wir versuchen nun einfach mal (unabh√§ngig zu dem Auto Beispiel aus den zuvorigen Abschnitten!) eine Methode f√ºr das Summieren zweier Ganzzahlen zu schreiben.</p>
                <p>Daf√ºr m√ºssen wir, wie bei einer mathematischen Funktion, erst einmal einen oder mehrere Werte in sie "hineinstecken", um einen weiteren "heraus", also zur√ºckzubekommen.</p>
                <p>In Java m√ºssen wir beachten, dass Java es vorschreibt (abgesehen von lambda-Funktionen - doch diese lassen wir in diesem AB au√üer Acht, bei mehr Interesse gerne direkt bei mir nachfragen), dass jede Funktion in einer Klasse steht und damit im Endeffekt nur √ºber ein Objekt dieser Klasse oder in einem Objekt dieser Klasse aufgerufen werden kann.</p>
                <p>Ferner startet jedes Java-Programm immer in der <code>main</code> Methode, die sich in jedem Java-Programm in der folgenden Form auffinden l√§sst: </p>
                <pre>
                    <code class="JAVA">
    public static void main(String[] args) {
        // Anweisungen
    }
                    </code>
                </pre>
                <p>Hier finden wir auch gleich einen nun bereits bekannten Sichtbarkeits-Modifizierer, <code>public</code>, der von einem weiteren bisher unbekanntnen Schl√ºsselwort <code>static</code> und schlie√ülich <code>void</code> gefolgt wird, bis wir schlie√ülich beim Methodennamen <code>main</code> angekommen sind.</p>
                <p>In den Klammern folgt dann ein sogenannter Parameter, <code>args</code> vom Typ <code>String[]</code> (Was genau das nun bedeutet, ist zum jetzigen Stand erst einmal unwichtig). Auf dieses Konzept gehe ich nun im Bezug auf unsere Summen-Methode ein.</p>
                <p>Parameter erlauben es uns, einer Methode Werte von au√üen zu √ºbergeben, mit denen wir dann etwas in der Methode anstellen k√∂nnen.</p>
                <p>So m√ºssen wir, um das Ergebnis einer Addition von zwei Ganzzahlen zu erhalten, unserer Methode zwei Parameter √ºbergeben: Den ersten und den zweiten Summanden.</p>
                <p>Da wir nur mit ganzen Zahlen rechnen, sollen beide Parameter von Typ <code>int</code> sein und die Namen <code>sum1</code> und <code>sum2</code> haben.</p>
                <p>Diese zwei √ºbergebenen Werte rechnen wir in unserer Methode zusammen und geben das Ergebnis wieder zur√ºck.</p>
                <p>So k√∂nnte eine relativ lange Version f√ºr unsere Additions-Methode wie folgt aussehen:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        int result = sum1 + sum2;
        return result;
    }
                    </code>
                </pre>
                <p>Wenn wir nun diese Methode einmal mit der <code>main</code> Methode vergleichen, f√§llt direkt etwas auf: Wo ist das <code>void</code> der <code>main</code> Methode hin?</p>
                <p>Nun, √ºber dieses <code>void</code> sagen wir dem Java-Compiler, dass eine Methode <i>keinen</i> Wert zur√ºckgibt, also genau das, was wir nicht wollen.</p>
                <p>Gerade unsere Additions-Methode soll ja aber das Ergebnis dieser Addition zur√ºckgeben.</p>
                <p>Also m√ºssen wir den R√ºckgabetypen dieser Methode √§ndern. Geben wir etwas in einer Methode zur√ºck, m√ºssen wir festlegen, von welchem Typ der zur√ºckgegebene Wert sein wird.</p>
                <p>In unserem Fall wissen wir ja, dass wir nur mit Ganzzahlen, also keinen Kommazahlen rechnen und k√∂nnen demnach den Datentyp <code>int</code> als R√ºckgabetyp festlegen.</p>
                <p>Und wie geben wir nun einen Wert zur√ºck?</p>
                <p>Dies erledigen wir √ºber die <code>return</code> Anweisung. Der Wert, der ihr folgt, wird zur√ºckgegeben.</p>
                <p>In unserer Additions-Methode geben wir den Wert von der Variablen <code>result</code> des Typs <code>int</code> zur√ºck. In dieser Variablen ist das eigentliche Ergebnis der Addition der beiden Summanden gespeichert.</p>
                <p>Um die Methode ein wenig k√ºrzer zu halten, w√§re folgendes auch vollkommen legitim:</p>
                <pre>
                    <code class="JAVA">
    public int sum(int sum1, int sum2){
        return sum1 + sum2;
    }
                    </code>
                </pre>
                <p>Dann testen wir doch einfach mal unsere Methode!</p>
                <p>Da in Java alles in Klassen stehen muss, m√ºssen wir also erst eine neue Datei erstellen und in dieser eine Klasse definieren, die allerdings keinerlei Eigenschaften besitzen muss. In ihr muss sich nur die <code>main</code> Methode befinden. Denn in dieser startet ja die Ausf√ºhrung unseres Java-Programms.</p>
                <p>Weiter ist es in Java notwendig die eigentliche Datei so zu nennen, wie die in ihr definierte Klasse hei√üt.</p>
                <p>Wir nennen unsere "Anfangsklasse" einfach <code>Main</code> und f√ºgen in diese das Code-Snippet der <code>main</code> Methode von weiter oben ein.</p>
                <p>Um im Java-Editor eine leere Java-Datei zu erstellen, klicke auf <code>Datei > Neu > Java</code> oder dr√ºcke <code>Strg + N</code></p>
                <p>Um diese Datei dann zu speichern und ihr einen Namen zu geben, klicke auf <code>Datei > Speichern</code> oder dr√ºcke <code>Strg + S</code>.</p>
                <p>In dem neu ge√∂ffneten Fenster kannst du nun den Speicherort und den Dateinamen festlegen.</p>
                <p>Abschlie√üend einfach auf <code>Speichern</code> klicken.</p>
                <p>Damit sollte in der Datei <code>Main.java</code> nun folgendes stehen:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>Um nun unsere eigene Methode auszuprobieren, m√ºssen wir diese einfach in die <code>Main</code> Klasse einf√ºgen und (!) das Schl√ºsselwort <code>static</code> hinzuf√ºgen.</p>
                <p>Warum genau dies nun n√∂tig ist w√ºrde nun etwas den Rahmen sprengen, deshalb sei lediglich gesagt, dass es notwendig ist und sonst einen Fehler geben w√ºrde, weil wir unsere Methode sp√§ter aus der <code>main</code> Methode und damit aus einem statischen Kontext ausrufen werden, wodurch die aufgerufene Methode automatisch auch als <code>static</code> definiert sein muss.</p>
                <p>Damit sieht die fertige <code>Main</code> Klasse nun so aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }
                    </code>
                </pre>
                <p>Jedoch k√∂nnen wir bisher immer noch nicht sehen, was unsere eigene <code>sum()</code> Methode denn zur√ºckgibt.</p>
                <p>Daf√ºr m√ºssen wir sie ja erstmal irgendwo aufrufen und ihr dabei zwei Werte von Typ <code>int</code> √ºbergeben, denn so haben wir es ja in unserer Methoden-Definition festgelegt.</p>
                <p>Hierf√ºr deklarieren wir in der <code>main()</code> Methode eine Variable <code>addition</code> vom Typ <code>int</code>.</p>
                <p>Anschlie√üend weisen wir ihr einen Wert zu. Jedoch nicht wie bisher direkt eine Zahl, sondern den Wert, den <code>sum()</code> zur√ºckgibt, wenn wir ihr zwei Ganzzahlen √ºbergeben.</p>
                <p>√úber den Befehl <code>System.out.println()</code> (Was im √ºbrigen auch einfach nur ein Methoden-Aufruf ist), k√∂nnen wir uns Werte auf der Konsole ausgeben lassen. N√§mlich genau den Wert, den wir ihr als Parameter (oder auch Argument genannt) √ºbergeben.</p>
                <p>Damit sieht unser fertiges Additions-Programm wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            int addition;
            addition = sum(2, 3);
            System.out.println(addition);
        }

        public static int sum(int sum1, int sum2){
            return sum1 + sum2;
        }
    }

    // Nach Complilieren und Ausf√ºhren wird auf der Konsole ausgegeben:
    // 5
                    </code>
                </pre>
                <p>Versuche doch einfach mal eine Methode <code>mul()</code> f√ºr die Multiplikation zweier Ganzzahlen zu schreiben. Oder wie sieht es denn aus, wenn wir drei statt nur zwei Zahlen addieren wollen?</p>
                <p>Probiere einfach ein bisschen herum, das f√∂rdert nur dein Verst√§ndnis!</p>
            </div>

            <div class="section">
                <h2>Basics - Zur√ºck zur Konstruktion des Autos</h2>
                <p>Nun mit unserem neuen Wissen wollen wir das Beispiel von einem Auto Objekt einmal zuende f√ºhren.</p>
                <p>Um einmal zu rekapitulieren:</p>
                <ul>
                    <li>Unser Auto Objekt soll folgende Attribute und Methoden besitzen: <code>color</code>, <code>model</code>, <code>fahren()</code> und <code>hupen()</code></li>
                    <li>Nach dem Konzept der Encapsulation m√ºssen wir uns nun √ºberlegen, welche Attribute und Methoden nach au√üen sichtbar sein sollen und welche nicht. In anderen Worten: Auf welche Eigenschaften von au√üen zugegriffen werden kann.</li>
                    <li>Zus√§tzlich m√ºssen wir auch erst einmal √ºberlegen, was genau wir in den Attributen speichern wollen. Daraus legen wir dann die entsprechenden Datentypen fest.</li>
                </ul>
                <p>Was muss denn nun alles von au√üen direkt aufrufbar sein?</p>
                <p>Nun, <code>color</code>, <code>model</code> m√ºssen ja eigentlich nicht wirklich direkt von au√üen abrufbar sein. Eventuell wollen wir sie im Laufe des Programmes einmal auslesen oder sogar √§ndern, ein Auto kann ja auch neu lackiert werden und das k√∂nnen wir dann ja √ºber den indirekten Zugriff √ºber die Getter und Setter regeln.</p>
                <p>Das hei√üt, dass wir <code>color</code> und <code>model</code> auf jeden Fall als <code>private</code> definieren werden.</p>
                <p>Bleibt noch die Frage des Datentyps.</p>
                <p>Der einfachere Fall zuerst: In <code>model</code> wollen wir ja einen Modelnamen speichern. Und aus was besteht ein Name? Genau, aus vielen aneinandergeh√§ngten Zeichen. Damit f√§llt unsere Wahl des Datentyps von <code>model</code> eindeutig auf <code>String</code>, da sich in einem <code>String</code> Zeichenketten speichern lassen.</p>
                <p>In <code>color</code> soll ja eine Farbe gespeichert werden. Dies k√∂nnten wir zwar ganz einfach durch eine Zeichenkette, also einen <code>String</code> realisieren, indem wir z.B. einfach den hex-code einer Farbe als <code>String</code> in <code>color</code> speichern, jedoch ist das relativ unpraktisch.</p>
                <p>Da kommt es uns nur gelegen, dass Java bereits eine eigene Klasse <code>Color</code> definiert hat, die es uns erlaubt simpel <code>Color</code> Objekte zu erstellen, in denen wir dann die Werte f√ºr R (Rot), G (Gr√ºn) und B (Blau) speichern k√∂nnen und uns zus√§tzlich noch einige andere sehr praktische Methoden zur Verf√ºgung stehen.</p>
                <p>Wichtig hierbei ist noch, dass wir, um diese Klasse in unserem Quellcode verwenden zu k√∂nnen, sie erst √ºber den folgenden Befehl, den wir sp√§ter ganz oben in die erste Zeile unseres Programms schreiben, importieren m√ºssen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;
                    </code>
                </pre>
                <p>Um ein Objekt <code>color</code> des Typs <code>Color</code> zu erstellen, verwenden wir folgendes Code-Snippet:</p>
                <pre>
                    <code class="JAVA">
    Color color = new Color(255, 0, 0);
                    </code>
                </pre>
                <p>Bevor ich nun genauer auf die Erkl√§rung dieses Snippets eingehe, erst noch ein paar Worte zu der Formulierung "<i>Ein Objekt ... des Typs ...</i>":</p>
                <p>Mit dieser Formulierung l√§sst sich ausdr√ºcken mithilfe welcher Klasse ein Objekt erstellt wird.</p>
                <p>So bedeutet in unserem Fall "<i>ein Objekt <code>color</code> des Typs <code>Color</code></i>", dass das Objekt <code>color</code> durch die Klasse <code>Color</code> festgelegt und sie damit also der Bauplan f√ºr das Objekt ist.</p>
                <p>In ihr steht also genau definiert, welche Eigenschaften und F√§higkeiten, also Attribute und Methoden ein Farb-Objekt haben sollte.</p>
                <p>Jetzt aber mal zur richtigen Erkl√§rung des Snippets:</p>
                <p>Bisher sind wir nur darauf eingegangen, was eine Klasse eigentlich ist und wof√ºr wir sie ben√∂tigen. Die Frage, wie wir denn nun ein Objekt nach dem Bauplan, den die Klasse vorgibt, erstellen ist allerdings immer noch offen.</p>
                <p>Das magische Wort lautet hier <b>Konstruktor</b>.</p>
                <p>Was ist nun aber ein Konstruktor?</p>
                <p>Jede Klasse muss √ºber eine Methode verf√ºgen, die bei der Erzeugung eines Objekts der Klasse aufgerufen wird. In dieser Methode k√∂nnen dann Werte initialisiert und erste Anweisungen durchgef√ºhrt werden. Diese Methode hei√üt Konstruktor.</p>
                <p>Er wird bei der Erstellung, also bei der Konstruktion eines Objekts aufgerufen.</p>
                <p>F√ºr ihn gibt es ein paar Sonderregeln, die immer gelten:</p>
                <p>Die wichtigste davon ist dabei mit Sicherheit die folgende: Der Konstruktor muss immer in jeder Klasse ohne Ausnahme wie die Klasse benannt sein.</p>
                <p>Gleichzeitig muss er immer als <code>public</code> definiert werden, da er ja von au√üerhalb eines Objektes aufgerufen wird.</p>
                <p>Eine weitere Besonderheit ist, dass ein Konstruktor niemals einen R√ºckgabetyp hat, in seiner Definition also nie ein <code>void</code> oder ein Datentyp stehen darf.</p>
                <p>Im Gro√üen und Ganzen ist der Konstruktor aber eben auch nur eine Methode.</p>
                <p>Das hei√üt f√ºr ihn gelten mit den paar zuvor genannten Einschr√§nkungen, exakt dieselben Regel wir f√ºr jede andere beliebige Methode.</p>
                <p>Also k√∂nnen wir auch einem Konstruktor bestimmte Parameter √ºbergeben, mit denen wir dann etwas in ihm anstellen k√∂nnen.</p>
                <p>So wollen wir ja schon bei der Erstellung eines Auto-Objektes unsere eigenen Farbe und den Modelnamen individuell festlegen lassen.</p>
                <p>Mit diesem ganzen neuen Wissen ist es uns nun sogar schon m√∂glich eine erste Version (bisher ohne weitere Methoden, als den Konstruktor) der Klasse <code>Auto</code> zu entwerfen.</p>
                <p>Um es einmal davor noch kurz und knapp zusammenzufassen:</p>
                <ul>
                    <li>Die Klasse soll die zwei Attribute <code>color</code> und <code>model</code> besitzen, die beide als <code>private</code> definiert werden. Dabei hat <code>color</code> den Datentyp <code>Color</code> und <code>model</code> den bereits bekannten Datentyp <code>String</code>.</li>
                    <li>Au√üerdem ben√∂tigt sie einen Konstruktor, der den gleichen Namen wie sie selbst hat - Also <code>Auto()</code> - und als <code>public</code> definiert ist. <br> Au√üerdem soll er die beiden Parameter <code>color</code> vom Typ <code>Color</code> und <code>model</code> vom Typ <code>String</code> entgegennehmen.</li>
                </ul>
                <p>Damit sieht unser erster Entwurf der <code>Auto</code> Klasse wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return this.color;
        }
        public void setColor(Color newColor){
            this.color = newColor;
        }

        public String getModel(){
            return this.model;
        }
        public void setModel(String newModel){
            this.model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei sei noch zu beachten, dass die Attribute bei ihrer Deklaration nicht direkt mit einem Wert initialisiert werden, sondern dies in dem Konstruktor geschehen soll.</p>
                <p>Eine Au√ünahme hierf√ºr stellen konstante Attribute dar, da diese immer direkt in ihrer Deklaration initialisiert werden m√ºssen. Anschlie√üend kann ihr Wert jedoch auch an keinem Punkt in unserem Programm abge√§ndert werden.</p>
                <p>W√ºrden wir zum Beispiel davon ausgehen, dass die R√§deranzahl eines Autos immer nur gleich 4 sein sollte, so k√∂nnten wir das folgende Attribut einf√ºgen (Das kannst du auch gerne tun üòÑ. F√ºr den weiteren Verlauf dieses Turtorials ist dies allerdings irrelevalt):</p>
                <pre>
                    <code class="JAVA">
    private final int tires = 4;
                    </code>
                </pre>
                <p>Zuletzt noch ein paar Worte zu den Gettern und Settern der beiden privaten Attribute:</p>
                <p>In diesen Methoden ist dir wahrscheinlich schon das Schl√ºsselwort <code>this</code> aufgefallen. In diesen F√§llen ist es zwar nicht notwendig, sp√§ter werden wir allerdings noch sehen, warum wir es verwenden sollten.</p>
                <p>Unter <code>this</code> kannst du eine Art Referenz auf das eigene Objekt verstehen. Ein Ausdruck wie <code>this.color</code> bezieht sich also immer direkt auf das Objekt, bzw. genau das Attribut dieses Objektes, aus dem es aufgerufen wird.</p>
                <p>Die folgende Version des Quellcodes w√§re damit auch vollkommen korrekt, wenn auch nicht gleich leicht verst√§ndlich:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Der Bauplan formt sich immer mehr und mehr</h2>
                <p>Unser erster Entwurf steht jetzt. Wir k√∂nnen die Dateien zwar schon komplilieren, jedoch fehlt noch eine kleine Sache.</p>
                <p>Setzen wir denn schon irgendwo die Werte der beiden Attribute?</p>
                <p>Um herauszufinden, was hier fehlt, erstelle, wenn du es bisher nicht sowieso von alleine weise vorausschauend gemacht hast, einen neuen Ordner und erstelle in diesem eine neue Datei f√ºr die Main-Klasse und eine weitere f√ºr die Auto-Klasse</p>
                <p>Ausgehend davon, dass der Ordner <i>AutoProject</i> hei√üt, sieht die Ordnerstruktur also wie folgt aus:</p>
                <pre>
                    <code class="DIR">
    AutoProjekt
        > Main.java
        > Auto.java
                    </code>
                </pre>
                <p>Den Basis-Code f√ºr eine die "Start"-Klasse, in der sich die <code>main()</code> Methode befindet, k√∂nnen wir hierbei einfach aus den Beispielen von zuvor kopieren und in <code>Main.java</code> einf√ºgen.</p>
                <p>Damit steht in <code>Main.java</code>:</p>
                <pre>
                    <code class="JAVA">
    public class Main {
        public static void main(String[] args) {
            // Anweisungen
        }
    }
                    </code>
                </pre>
                <p>In die <code>Auto</code> Klasse f√ºgst du einfach den Entwurf aus dem letzten Abschnitt ein:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color;

    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
                <p>Hierbei darfst du jedoch nicht den Import der <code>Color</code> Klasse vergessen, sonst meckert der Compiler bereits beim Kompilieren.</p>
            </div>

            <div class="section">
                <h2>Basics - Initialisierung im Konstruktor</h2>
                <p>Wie ich im letzen Abschnitt bereits ein wenig vorweg genommen habe, weisen wir unseren beiden Attributen bisher noch nirgendwo Werte zu.</p>
                <p>Das hei√üt sie zeigen bisher noch auf gar keine Referenz oder einen Wert, sondern lediglich <code>null</code>.</p>
                <p>Aus dem Abschnitt Konstruktoren im Allgemeinen ist dir eventuell noch im Kopf geblieben, f√ºr was sie denn normalerweise verwendet werden. N√§mlich f√ºr die Initialisierung von Attributen.</p>
                <p>In unserem Fall wollen wir daf√ºr ja dem Konstruktor zwei Werte √ºbergeben, die er dann den beiden Attributen zuweist.</p>
                <p>Also schreiben wir doch einfach mal den Code hierf√ºr. Das sollte leicht getan sein, sollte der Konstruktor also so aussehen:</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        color = color;
        model = model;
    }
                    </code>
                </pre>
                <p>Nun ja... </p>
                <p>Das ist doch schon etwas sehr verwirrend.</p>
                <p>Der Java-Compiler versteht zwar genau, was wir eigentlich meinen, wir selbst sind allerdings etwas verwirrt.</p>
                <p>Um diese Verwirrung zu beseitigen, verwenden wir f√ºr solche F√§lle einfach das <code>this</code> Schl√ºsselwort, um eindeutig zu zeigen, welche Variable woherkommt.</p>
                <pre>
                    <code class="JAVA">
    public Auto(Color color, String model){ 
        this.color = color;
        this.model = model;
    }
                    </code>
                </pre>
                <p>So ist nun klar ersichtlich, dass der Teil des Ausdrucks links neben dem Gleichheitszeichen sich eindeutig auf das Attribut der Klasse bezieht und der rechte Teil die beiden Parameter meint.</p>
            </div>

            <div class="section">
                <h2>Basics - Unser Auto soll fahren!</h2>
                <p>Da unser Auto bisher noch nicht wirklich etwas kann und das ja doch echt ein bisschen langweilig w√§re, f√ºgen wir nun noch unsere zwei anfangs geplanten Methoden <code>fahren()</code> und <code>hupen()</code> ein.</p>
                <p>Um mit diesen allerdings nicht den Rahmen zu sprengen, halten wir sie sehr simpel und geben in ihnen nur einen Hinweis in der Konsole aus, dass sie aufgerufen wurden.</p>
                <p>Beide Methoden sollen dabei von au√üen aufgerufen werden k√∂nnen und nichts zur√ºckgeben.</p>
                <p>Damit lautet die Methoden-Definition wie folgt:</p>
                <pre>
                    <code class="JAVA">
    public void fahren(){ 
        System.out.println("Das Model " + this.model + " f√§hrt");
    }

    public void hupen(){
        System.out.println("Das Model " + this.model + " hupt");
    }
                    </code>
                </pre>
                <p>Hier verwenden wir, damit das Beispiel doch ein wenig interessanter wird, ein sehr praktisches Feature von Strings:</p>
                <p>Diese lassen sich n√§mlich unter Verwendung des Pluszeichens (+) sehr einfach zusammenf√ºgen.</p>
                <p>In <code>model</code> ist ja der Modelname des Auto-Objekts als <code>String</code> gespeichert. Damit k√∂nnen wir ihn auch ganz einfach in einen Satz mit einf√ºgen und uns diesen zusammengef√ºgten Satz anschlie√üend in der Konsole anschauen.</p>
                <p>So sieht unsere fertige <code>Auto</code> Klasse nun vervollst√§ndigt wie folgt aus:</p>
                <pre>
                    <code class="JAVA">
    public class Auto{
        private Color color;
        private String model; 

        public Auto(Color color, String model){ 
            this.color = color;
            this.model = model;
        }

        public void fahren(){ 
            System.out.println("Das Model " + this.model + " f√§hrt");
        }

        public void hupen(){
            System.out.println("Das Model " + this.model + " hupt");
        }

        public Color getColor(){
            return color;
        }
        public void setColor(Color newColor){
            color = newColor;
        }

        public String getModel(){
            return model;
        }
        public void setModel(String newModel){
            model = newModel;
        }
    }
                    </code>
                </pre>
            </div>

            <div class="section">
                <h2>Basics - Das Auto f√§hrt!</h2>
                <p>Mit unserer fertigen <code>Auto</code> Klasse k√∂nnen wir nun also unser erstes richtiges Auto Objekt erstellen.</p>
                <p>Daf√ºr gehen wir nun in die <code>main()</code> Methode der <code>Main</code> Klasse und erstellen in dieser unser Objekt.</p>
                <p>Wie bereits in dem Abschnitt √ºber den Konstruktor im Allgemeinen gezeigt, rufen wir bei der Erstellung eines Objektes einer Klasse den Konstruktor √ºber das Schl√ºsselwort <code>new</code> gefolgt von seinem Namen auf.</p>
                <p>Allerdings ben√∂tigen wir ja zun√§chst erst noch zwei Werte, die wir ihm √ºbergeben k√∂nnen - Die Farbe und den Modelnamen.</p>
                <p>Hierf√ºr m√ºssen wir nun zuerst in die erste Zeile in der <code>Main.java</code> Datei ebenfalls die Klasse <code>Color</code> importieren, da wir ja dem Konstruktor ein Objekt des Typs <code>Color</code> √ºbergeben m√ºssen.</p>
                <p>Dann initialisieren wir einfach zwei Variablen in der <code>main()</code> Methode, <code>farbe</code> vom Typ <code>Color</code> und <code>modelName</code> vom Typ <code>String</code>.</p>
                <p>Diesen k√∂nnen wir dann jeweils einen beliebigen Wert zuweisen. F√ºr <code>modelName</code> suchen wir uns einfach einen Auto-Modelnamen, w√§hrend <code>farbe</code> ja ein Objekt ist, weshalb wir hier den Konstruktor von <code>Color</code> aufrufen und ihm drei Werte f√ºr R, G und B √ºbergeben m√ºssen.</p>
                <p>Diese beiden Variablen √ºbergeben wir dann einfach dem <code>Auto</code> Konstruktor.</p>
                <p>Um anschlie√üend zu √ºberpr√ºfen, ob unser Auto-Objekt auch das tut, was es soll, k√∂nnen wir nun noch √ºber das erstellte Objekt <code>auto1</code> die beiden Methoden <code>fahren()</code> und <code>hupen()</code> aufrufen.</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Color farbe = new Color(0, 0, 0); // schwarz
            String modelName = "AMG";
            
            Auto auto1 = new Auto(farbe, modelName);
            auto1.fahren();
            auto1.hupen();
        }
    }

    // Gibt auf der Konsole aus:
    // Das Model AMG f√§hrt
    // Das Model AMG hupt
                    </code>
                </pre>
                <p>Durch dieses Snippet sollte auch gleich klar werden, wie man Methoden, die als <code>public</code> definiert sind √ºber ein Objekt aufrufen kann.</p>
                <p>Probiere doch einfach mal dir nur den Modelnamen des Autos auf der Konsole ausgeben zu lassen oder ein zweies Auto-Objekt <code>auto2</code> zu erstellen, welches dann allerdings eine andere Frabe und einen anderen Modelnamen haben soll. Rufe dann auch hier die beiden Methoden auf und schau, was auf der Konsole ausgegeben wird.</p>
                <p>Abschlie√üend sei noch gesagt, dass es auch k√ºrzer als in dem Beispiel oben geht, da wir die beiden Variablen <code>farbe</code> und <code>modelName</code> eigentlich nicht ben√∂tigen, sondern deren Werte direkt dem Konstruktor √ºbergeben k√∂nnen.</p>
                <p>Damit l√§sst sich das Programm ein wenig abk√ºrzen:</p>
                <pre>
                    <code class="JAVA">
    import java.awt.Color; 

    public class Main {
        public static void main(String[] args) {
            Auto auto1 = new Auto(new Color(0, 0, 0), "AMG");
            auto1.fahren();
            auto1.hupen();
        }
    }

    // Gibt auf der Konsole aus:
    // Das Model AMG f√§hrt
    // Das Model AMG hupt
                    </code>
                </pre>
            </div>
        </div>
    </div>
</body>
</html>